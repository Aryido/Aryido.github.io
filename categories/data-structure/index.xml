<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>data-structure on Aryido Tech Note</title><link>https://aryido.github.io/categories/data-structure/</link><description>Recent content in data-structure on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 May 2024 22:10:30 +0800</lastBuildDate><atom:link href="https://aryido.github.io/categories/data-structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf - 序列化反序列化詳解</title><link>https://aryido.github.io/posts/data-structure/protobuf-serialization/</link><pubDate>Wed, 01 May 2024 22:10:30 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-serialization/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 &lt;strong>.proto&lt;/strong> 檔案，就可以生成&lt;strong>不同的程式語言&lt;/strong>來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :&lt;/p>
&lt;ul>
&lt;li>Varint Encoding&lt;/li>
&lt;li>Zigzag Encoding&lt;/li>
&lt;li>Wire Type 類型&lt;/li>
&lt;li>T-L-V 儲存方式&lt;/li>
&lt;/ul>
&lt;p>熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf - Encoding 結構</title><link>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</link><pubDate>Sun, 28 Apr 2024 17:56:27 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>隨者網路傳輸、頻寬與硬體的設備的改善和增強，能傳遞資料量也越來越大、越來越複雜，這時我們也不再只是追求能夠將資料傳遞完成，而是更加要求&lt;strong>短時內傳遞大量的資料&lt;/strong>，故勢必會需要強化&lt;strong>序列化&lt;/strong>和&lt;strong>壓縮&lt;/strong>的技術。這篇會介紹 Protobuf 編碼後的 byte array 結構，以及會這樣設計的思路，當有了基本的認識後，就會明白 Protobuf 為何它可以比 JSON、XML 傳輸效率更高，更能壓縮資料，實現高效率。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf 簡介</title><link>https://aryido.github.io/posts/data-structure/protobuf/</link><pubDate>Fri, 26 Apr 2024 00:44:35 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Protobuf 全稱 Protocol Buffers ，是一種輕量級的資料交換格式，最初是由 Google 開發的「&lt;strong>可擴展的序列化資料結構&lt;/strong>」，現已成為一個開源項目，其語⾔中⽴且平台無關，適合高性能且對響應速度有高要求的資料傳輸場景；也因為有&lt;strong>資料壓縮&lt;/strong>的能力，故也可用於資料儲存。Protobuf 的核心思想是&lt;strong>先定義好 data schema&lt;/strong> ，然後可根據所需的語言&lt;strong>生成對應的 code base&lt;/strong>，方便使用者操作 :「序列化寫入、反序列化讀取」。&lt;/p>
&lt;p>Profobuf 需要注意的缺點是為&lt;strong>二進制格式&lt;/strong>，故編碼之後不具有可讀性，需要反序列化後才能看得懂資料內容 ; 雖然是個好東西，但並非是個用來完全取代 JSON 的解決方案，JSON 仍有其可讀性高、易操作及通用性高等優點，在多數 API 設計的場景之下，JSON 仍然是最好的選擇。&lt;/p>
&lt;/blockquote></description></item><item><title>B Tree</title><link>https://aryido.github.io/not-yet-finished/b-tree/</link><pubDate>Sat, 25 Nov 2023 16:23:31 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/b-tree/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>B-tree 是一種自平衡的樹，能夠保持資料的有序性，能讓搜尋、插入、刪除都在 logN 時間內完成。B-tree 是一個廣義化的 binary search tree，可以擁有多於 2 的 sub-Node。
B-tree 與自平衡 binary search tree 最大不同，是 B-tree 做了讀寫操作做的優化，減少定位記錄時所經歷的中間過程，從而加快存取速度。常應用在 database 和 file-system 實現上。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf &amp; Avro</title><link>https://aryido.github.io/not-yet-finished/protobuf-avro/</link><pubDate>Sat, 02 Sep 2023 20:05:20 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/protobuf-avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在現實情境中，data 的設計總是會不斷變化。故我們都會希望可以變成&lt;strong>能夠快速添加或刪除一些 field&lt;/strong>，但不影響太多系統的設計。目前 Protobuf 和 Avro 都支持 schema reversion，它允許你在不同的時間獨立地更新系統的不同組件，而不用擔心兼容性問題。&lt;/p>
&lt;/blockquote></description></item><item><title>Avro</title><link>https://aryido.github.io/posts/data-structure/avro/</link><pubDate>Sun, 23 Apr 2023 15:27:54 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Avro 是一個 data serialization 框架 ，是 Apache Hadoop 下的一個子項目，是一個可跨多種程式語言和平台的&lt;strong>傳輸資料格式&lt;/strong>。Avro 可使用 JSON 格式來描述 data structure，並且支持&lt;strong>架構演進&lt;/strong>，保持向後、向前的相容性。
Avro 也提供了編解碼和二進制格式，使得在高吞吐量的應用場景中非常有用且高效。&lt;/p>
&lt;/blockquote></description></item><item><title>Avro 簡介</title><link>https://aryido.github.io/not-yet-finished/avro/</link><pubDate>Sun, 23 Apr 2023 15:27:54 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Avro 是一個 data serialization 框架 ，為 Apache Hadoop 下的一個子項目，定義一個可跨多種程式語言和平台的&lt;strong>傳輸資料格式&lt;/strong>。Avro 可使用 JSON 格式來描述 data structure，並且支持&lt;strong>架構演進&lt;/strong>，保持向後/向前的相容性。 Avro 也提供了編解碼和二進制格式，使得在高吞吐量的應用場景中非常有用且高效。&lt;/p>
&lt;/blockquote></description></item><item><title>Graph 介紹</title><link>https://aryido.github.io/posts/data-structure/graph/</link><pubDate>Tue, 13 Sep 2022 21:37:08 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/graph/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Graph 用於表示物體與物體之間存在某種關係的結構，是內存中不一定連續的資料，每個節點會一個或多個 Reference 指向其他節點&lt;/p>
&lt;ul>
&lt;li>可能有環&lt;/li>
&lt;li>分無向圖和有向圖&lt;/li>
&lt;li>沒有固定入口&lt;/li>
&lt;li>可能有多個入口&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Binary Search Tree</title><link>https://aryido.github.io/posts/data-structure/binary-search-tree/</link><pubDate>Sun, 11 Sep 2022 14:53:52 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/binary-search-tree/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>二元搜尋樹（英語：Binary Search Tree），也稱為有序二元樹（ordered binary tree）或排序二元樹（sorted binary tree）。 從 wiki 上得到的時間與空間複雜度 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">演算法&lt;/th>
&lt;th style="text-align:center">平均&lt;/th>
&lt;th style="text-align:center">最差&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">空間&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">搜尋&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">插入&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">刪除&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/blockquote></description></item></channel></rss>
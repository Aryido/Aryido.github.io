<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kubernetes on Aryido Tech Note</title><link>https://aryido.github.io/categories/kubernetes/</link><description>Recent content in kubernetes on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Oct 2023 00:00:30 +0800</lastBuildDate><atom:link href="https://aryido.github.io/categories/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes - Workloads &amp; Workload Resources</title><link>https://aryido.github.io/posts/kubernetes/workloads/</link><pubDate>Wed, 04 Oct 2023 00:00:30 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/workloads/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>Workload 是指在 Kubernetes Pod 內運行的應用程式&lt;/strong>。但是 Pod 並不能保證總是可用的，所以需要管理它們。但若直接管理 Pod 的話，工作量將會非常大且繁瑣，為了減輕負擔，Kubernetes 提供 Workload Resources 來管理一組 Pods。即 &lt;strong>Workload Resource 是 Kubernetes 中，定義和管理 Workload 的特定 API 物件&lt;/strong>，例如 Deployment、StatefulSet 等等都是屬於 Workload Resource。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Deployment</title><link>https://aryido.github.io/posts/kubernetes/deployment/</link><pubDate>Sun, 01 Oct 2023 18:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/deployment/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Deployment 是 Kubernetes 最經常使用的的一種工作負載(Workloads)，以 YAML 格式描述狀態，提供聲明式(declarative)的設定。基本用法為 :&lt;/p>
&lt;ul>
&lt;li>管理 Pod 的 replica 數量&lt;/li>
&lt;li>管理升級回滾的策略&lt;/li>
&lt;/ul>
&lt;p>Deployment 是用來&lt;strong>編排無狀態 pod 的一種控制器資源&lt;/strong>，官方也建議應該透過 Deployment 來佈署 Pod &amp;amp; Replicaset。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - 應用之間是如何溝通呢 ?</title><link>https://aryido.github.io/posts/kubernetes/app-communication/</link><pubDate>Sun, 11 Jun 2023 00:29:32 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/app-communication/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>kubernetes 可以創建多個 Pods，Pod 內有一個或多個 Container，那麼 Container 之間是怎麼溝通的的呢 ? 這裡歸類出一些 case :&lt;/p>
&lt;ul>
&lt;li>不同網路下，不同 pod 間的 container 的通訊&lt;/li>
&lt;li>同一網路下，不同 pod 間的 container 的通訊&lt;/li>
&lt;li>同一個 pod 中，不同的 container 的通訊&lt;/li>
&lt;/ul>
&lt;p>以下來對這些 case 進行說明。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - DNS Service Discovery</title><link>https://aryido.github.io/posts/kubernetes/dns-service-discovery/</link><pubDate>Wed, 31 May 2023 22:58:42 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/dns-service-discovery/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Kubernetes 是可以支援 &lt;code>ClusterIP:Port&lt;/code> 、&lt;code>PodIP:Port&lt;/code> 的形式，來完成相互溝通的，但是這樣會帶來些問題，因為 Kubernetes 內部 Pod 和 Service 都有機會重啟的，這會導致 Pod 和 Service 的 IP 發生變化；但 Service 名字等一些標識資訊是不會經常變動的，所以 &lt;strong>Kubernetes 更推薦通過 Service 的名字來訪問服務&lt;/strong>，這就是服務發現。Service Discovery 是一種機制，通過該機制，服務可以動態發現彼此，而無需 hardcode 硬寫 IP 或 endpoint 配置。可以讓我們只透過 Service 的名稱，就能找到相對應 Pod ，而非使用 IP 地址訪問。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Service</title><link>https://aryido.github.io/posts/kubernetes/service/</link><pubDate>Sat, 27 May 2023 10:07:23 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/service/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pod 的生命週期是動態的，因為 cluster 會根據需求，動態地創建或銷毀 Pod ，重啟的 Pod 自然也伴隨着 IP 地址的更動。為了解決這問題，kubernetes 在 客戶端和 Pod 間，引入了一個名為 Service 的組件，它會在 pod 的前方提供了一個穩定的網路端點。&lt;strong>不只可以建立內部 Pod 之間的通信，讓 Pod 間可以用 domain name 的方式相互溝通；另外也可以建立外部與 Pod 的溝通管道&lt;/strong>。 最後 Service 也有能力爲這些 Pod 進行負載分配，平均每個 Pod 的使用率。&lt;/p>
&lt;/blockquote></description></item><item><title>Rolling vs Canary vs Blue-Green</title><link>https://aryido.github.io/posts/others/rolling-canary-bluegreen/</link><pubDate>Wed, 17 May 2023 00:26:34 +0800</pubDate><guid>https://aryido.github.io/posts/others/rolling-canary-bluegreen/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現今應用程式發展迅速， app 的更新也變得越來越頻繁，在微服務、DevOps、Cloud-native 的迭代過程中，最終都需要上線。上線就需要部署；需要部署就意味著有修改；修改則意味著有風險，要如何在&lt;strong>盡量不影響 user 的前提下，讓 app 升版呢&lt;/strong> ? 這時就有一些&lt;strong>部屬策略&lt;/strong>可以考慮。對於 Deployment Strategies 有一些基本的專有名詞和觀念，例如 :&lt;/p>
&lt;ul>
&lt;li>Recreate&lt;/li>
&lt;li>Rolling&lt;/li>
&lt;li>Blue-Green&lt;/li>
&lt;li>Canary&lt;/li>
&lt;/ul>
&lt;p>對於應該使用哪種 Deployment Strategy 、它們的工作原理、優缺點等等，以下會做些基本介紹。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Ingress</title><link>https://aryido.github.io/posts/kubernetes/ingress/</link><pubDate>Fri, 12 May 2023 23:11:25 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/ingress/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Kubernetes 若要把應用暴露於 &lt;strong>Cluster 外部&lt;/strong> ，已知可以使用 &lt;strong>NodePort&lt;/strong> 和 &lt;strong>LoadBlancer&lt;/strong> 類型的 Service，但當 Service 越來越多時，我們就需要管理更多的 Port Number，也會使得維運上更加複雜。這時就可以考慮使用 Kubernetes Ingress ，它可用來代理不同 Kubernetes Service，能使 Node 對外開放&lt;strong>統一的 port&lt;/strong> ，也可將外部的請求轉發到 &lt;strong>Cluster 內不同的 Service&lt;/strong> 上，來實現負載均衡。 Ingress 專注於 Cluster 對外的暴露、負載均衡、L7轉發、 Virtual Hosting 等功能。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes: command &amp; arguments</title><link>https://aryido.github.io/posts/kubernetes/command-arguments/</link><pubDate>Sun, 07 May 2023 20:22:59 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/command-arguments/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>當我們在編寫 Kubernetes Pod 相關的 yaml spec 時，有時會針對 spec.containers ，設置啟動時要執行的命令及其參數，而 Kubernetes 提供 &lt;code>command &lt;/code> 和 &lt;code>args&lt;/code>，兩種方式可以選擇。但這時候就會出現一些疑問 :&lt;/p>
&lt;ul>
&lt;li>這兩個差異是甚麼 ?&lt;/li>
&lt;li>Docker Image 中如果自帶 ENTRYPOINT 和 CMD ，若 Kubernetes 再設置 &lt;code>command&lt;/code> 和 &lt;code>args&lt;/code> 會發生甚麼事情呢 ?&lt;/li>
&lt;/ul>
&lt;p>以下就來簡單說明一下。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Pod 實現解析</title><link>https://aryido.github.io/posts/kubernetes/pod-implementation/</link><pubDate>Sat, 01 Apr 2023 17:34:53 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/pod-implementation/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pod 是 Kubernetes 中最小的運行單位，它可以包含一個或多個 container。Pod 的實現原理主要涉及以下幾個方面：&lt;/p>
&lt;ul>
&lt;li>容器技術 : 實現隔離和獨立運行&lt;/li>
&lt;li>共享網絡和存儲 : Pod 中的所有容器共享相同的網絡和存儲空間&lt;/li>
&lt;li>Pod 調度 : 調度器會監測節點的資源利用率，將 Pod 調度到適合的節點上運行。&lt;/li>
&lt;li>生命週期管理 : 當 Pod 發生故障或需要擴展時，控制器會自動創建、刪除或調整 Pod 的數量。&lt;/li>
&lt;/ul>
&lt;p>在 Kubernetes 中，Pod 是容器組的概念，爲應用程序提供了一個更加靈活的運行環境，負責管理容器的生命周期和資源。&lt;/p>
&lt;/blockquote></description></item><item><title>Helm 簡介</title><link>https://aryido.github.io/posts/kubernetes/helm/</link><pubDate>Tue, 21 Mar 2023 22:02:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/helm/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Helm 是 kubernetes 的包管理工具。 Helm 有一個公共 Repository ，裏面主要都是配置文件，會把 Kubernetes 服務中各種元件 yaml ，統一打包成一個叫做 Chart 的模組，然後透過 value.yaml，可用來&lt;strong>統一&lt;/strong>管理與設定 Kubernetes ，幫助 developer 和系統管理員，更輕鬆地部署、管理和升級 Kubernetes 中的應用程式。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - DaemonSet</title><link>https://aryido.github.io/posts/kubernetes/daemonset/</link><pubDate>Tue, 14 Mar 2023 22:35:58 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/daemonset/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>k8s Cluster 並不直接與 Pod 做互動，而是透過一些管理元件來處理 Pod ，這些管理元件總體被稱為 Workload，這裏介紹 DaemonSet 控制器。DaemonSet 用於提供 Node 基本設施的 Pod，會確保在&lt;strong>所有(或是特定)節點&lt;/strong>上，一定運行著指定的一個 Pod。若想只運行在特定節點運行 DaemonSet Pod，可藉由給定的&lt;strong>標籤&lt;/strong>，讓 Pod 可以只在特定節點上運行。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Job 簡介</title><link>https://aryido.github.io/posts/kubernetes/job/</link><pubDate>Thu, 02 Mar 2023 23:10:15 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/job/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們知道 kubernetes 的 deployment 可以生成並管理 Pod ，且盡量維持其狀態為 Running 。但有的時候我們會有&lt;strong>只運行一次性任務的需求&lt;/strong>，這時候就可以使用 &lt;a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">kubernetes Job&lt;/a>。 Kubernetes Job 用於處理一次性工作，會創建一個或多個 Pod，並在該工作完成後終止這些 Pod。&lt;/p>
&lt;/blockquote></description></item><item><title>kubectl 簡單筆記</title><link>https://aryido.github.io/posts/kubernetes/kubectl/</link><pubDate>Sun, 25 Dec 2022 21:38:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/kubectl/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>kubectl 是針對 k8s cluster 的 API Server 發送命令的工具，有些指令會改變 K8s cluster 的 state 和任何對應到的環境變量。默認情況下，kubectl 在 &lt;strong>$HOME/.kube&lt;/strong> 目錄下查找名為 config 的文件，kubectl 使用該 config 文件來查找要通訊的 K8s cluster 資料。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 2</title><link>https://aryido.github.io/posts/kubernetes/overview-2/</link><pubDate>Sat, 24 Dec 2022 12:30:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在上一篇文章中，簡單介紹了 Kubernetes 的架構，接下來簡介 Kubernetes 在部屬 app 時的單位 Pod 。 Pod 對多容器的支持是 K8 最基礎的設計理念，但 Pod 應該怎麼被管理呢 ? 怎麼和外網連線呢 ? 這些部分由如下元件提供功能解決 :&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>Service&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>像在實現進階的操作如:負載均衡、滾動更新、安全與監控等概念，都會跟這些元件有關係。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 1</title><link>https://aryido.github.io/posts/kubernetes/overview-1/</link><pubDate>Mon, 19 Dec 2022 23:38:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>從第一次聽到 Kubernetes 以來，已經有一年多了，永遠都記得 k8s 名稱的由來只是保留「開頭 K」及「結尾 S」，然後中間的英文字母數量剛好是 8 個英文字就這樣命名了&amp;hellip;。全球三大雲服務商，AWS、Azure 和 GCP 都有提供託管 Kubernetes 集群服務( EKS、AKS、GKE )，可見其有名火熱程度。現在終於有機會在工作上碰到這項技術，就來寫些簡單筆記吧 !&lt;/p>
&lt;/blockquote></description></item></channel></rss>
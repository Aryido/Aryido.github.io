<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Aryido Tech Note</title><link>https://aryido.github.io/categories/leetcode/</link><description>Recent content in LeetCode on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 09 Feb 2023 22:56:05 +0800</lastBuildDate><atom:link href="https://aryido.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>15. 3Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode15/</link><pubDate>Thu, 09 Feb 2023 22:56:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode15/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>算是 Two Sum 的一種另類進階，從 &lt;em>nums&lt;/em> 中找出和為 0 的三個 element ，並組成 &lt;em>List of list&lt;/em> 。特別注意，不能有兩個內容一樣的 list。因為整個題目並沒有對 &lt;em>nums&lt;/em> 的 &lt;em>index&lt;/em> 有任何要求，故可以&lt;em>把 nums 排序&lt;/em>，為解題拓開另一種思路。&lt;/p>
&lt;/blockquote></description></item><item><title>16. 3Sum Closest</title><link>https://aryido.github.io/posts/leetcode/leetcode16/</link><pubDate>Wed, 08 Feb 2023 21:56:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode16/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題跟 15 題非常相似，又增加了些許難度。題目敘述一樣也簡單，求 nums 內最接近 &lt;em>target&lt;/em> 值的三數和。優化關鍵點一樣是，&lt;em>把 nums 排序&lt;/em>，這樣就可以確定指針滑動方向。&lt;/p>
&lt;/blockquote></description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://aryido.github.io/posts/leetcode/leetcode26/</link><pubDate>Sun, 25 Dec 2022 15:05:58 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode26/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題要我們從&lt;strong>有序數組&lt;/strong>中去除重複項，題目難度雖然被歸為 easy 等級，但在&lt;strong>條件限制&lt;/strong>上的討論，蠻多東西可以釐清討論的。 英文方面寫得蠻長，記得看到最後，有些限制如 :&lt;/p>
&lt;ul>
&lt;li>&lt;em>O(1)&lt;/em> extra memory&lt;/li>
&lt;li>The relative order of the elements should be kept the same.&lt;/li>
&lt;/ul>
&lt;p>所以&lt;strong>不要用 Set 或另外 array 去寫&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - binary search</title><link>https://aryido.github.io/posts/leetcode/leetcode410-2/</link><pubDate>Sun, 11 Dec 2022 18:32:09 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹用 dp 方式把這題給解了，但看一下 Related Topics 發現也可以用 Binary Search 求解，上網參考大神們的解法，感覺特別巧妙。因為這題可用 dp 和 Binary Search，也變成是一道高頻難題。
這邊記錄一下大神們的想法。&lt;/p>
&lt;/blockquote></description></item><item><title>47. Permutations II</title><link>https://aryido.github.io/posts/leetcode/leetcode47/</link><pubDate>Sun, 04 Dec 2022 18:41:26 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode47/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 46. Permutations 的進階，現在有 duplicate 數字，一樣使用 backtrack 來求解。從數學上來說，&lt;em>n&lt;/em> 個 element ，且將相同的事物歸為一組, 可歸成&lt;em>k&lt;/em>組, 且每組有&lt;em>m_i&lt;/em>個，其 Permutation 一共有 &lt;em>n!/(m_1!m_2!&amp;hellip;m_k!)&lt;/em> 種排序，高中數學題需要思考下的基礎題，要用程式模擬這個過程也有點難度，被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>46. Permutations</title><link>https://aryido.github.io/posts/leetcode/leetcode46/</link><pubDate>Wed, 30 Nov 2022 23:38:55 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode46/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是一道經典的全排列問題，這邊使用 backtrack 來求解。從數學上來說，&lt;em>n&lt;/em> 個 element 的 Permutation 一共有 &lt;em>n!&lt;/em> 種排序，思考起來算蠻簡單的，但要用程式模擬這個過程，是有點難度的，被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - dynamic programming</title><link>https://aryido.github.io/posts/leetcode/leetcode410/</link><pubDate>Sun, 27 Nov 2022 20:26:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題真的蠻難的，一開始看題目我也覺得很繞口，給了一個非負數的 nums 和一個 m 代表把 nums 分成 m 個 group 且 每個 group non-empty 並取 m 個 group 中的最大值。但注意，前面只是代表一種&lt;strong>切法&lt;/strong>而已，我們是要找所有可能&lt;strong>切法&lt;/strong>之中的最小值。看一下 Related Topics 發現可以用 Binary Search 和 DP 求解，也是一道高頻題目。&lt;/p>
&lt;/blockquote></description></item><item><title>877. Stone Game</title><link>https://aryido.github.io/posts/leetcode/leetcode877/</link><pubDate>Fri, 25 Nov 2022 23:36:44 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode877/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>石頭遊戲，兩個人輪流選石頭，Alex 先選，每次只能選開頭或結尾，最終獲得石頭總數多的人獲勝。 乍看之下不好想到可以用 DP 解，但其實可用一個 2D-state 去描述遞迴的狀態。 這題一開始會好奇是因為負評倒讚很多，個人是感覺能從 Game Theory 單純想出這結論也是蠻厲害的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>1143. Longest Common Subsequence</title><link>https://aryido.github.io/posts/leetcode/leetcode1143/</link><pubDate>Tue, 22 Nov 2022 22:46:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1143/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是求最長相同的&lt;strong>子序列&lt;/strong>，可用 Dynamic Programing 來做，最難的還是想出狀態函數。這裡使用 2D-dp ，其中 dp[i][j] 表示 :&lt;/p>
&lt;ul>
&lt;li>text1 的前 i 個字符&lt;/li>
&lt;li>text2 的前 j 個字符&lt;/li>
&lt;/ul>
&lt;p>的最長相同的子序列的字符個數&lt;/p>
&lt;/blockquote></description></item><item><title>63. Unique Paths II</title><link>https://aryido.github.io/posts/leetcode/leetcode63/</link><pubDate>Sun, 13 Nov 2022 15:22:47 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode63/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 62. Unique Paths 的延伸，在路徑中加了一些 obstacle ，用 Dynamic Programming 二維的 dp 數組來解題&lt;/p>
&lt;/blockquote></description></item><item><title>139. Word Break</title><link>https://aryido.github.io/posts/leetcode/leetcode139/</link><pubDate>Sat, 12 Nov 2022 22:10:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode139/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>一道很經典的題目，是給定一 string ，能不能分被拆分成 wordDict 裡面的單詞。注意這題，wordDict 裡面的單詞可以重複使用，即單詞使用沒有次數限制，所以 string 可以分成任意段，這就增加了題目的難度。解法蠻多種的，可先從 brute force 下手，再加上暫存優化後，就是蠻標準的 dp 解了，來解一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/posts/leetcode/leetcode78/</link><pubDate>Sun, 06 Nov 2022 22:54:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題很經典的問題 the power set ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選就可以得出。但在程式上卻有點點難度，會被歸類到 Medium 等級。這邊我是使用類似於一種深度優先搜索，但其實也有非遞回式的解法，都可看看並練習。&lt;/p>
&lt;/blockquote></description></item><item><title>560. Subarray Sum Equals K</title><link>https://aryido.github.io/posts/leetcode/leetcode560/</link><pubDate>Sun, 23 Oct 2022 11:03:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode560/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題我看起來也是很技巧性的題目，一開始要把 subarray 的特性掌握的淋漓盡致，並且想到用 hashmap 來建立快速查找關係，真的有點困難&amp;hellip;但也是這道題的魅力吧 ! 基本上 hashmap 題目大概都會偏向這種步驟應用，多注意可以讓自己視野開闊。&lt;/p></description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://aryido.github.io/posts/leetcode/leetcode1011/</link><pubDate>Sat, 15 Oct 2022 19:18:43 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1011/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題是 Google 面試題，在 Hide Hint 中表示可以使用 binary-search 解決，剛開始覺得蠻 tricky 的，但仔細思考會覺得 binary-search 很符合這題目。&lt;/p></description></item><item><title>127. Word Ladder</title><link>https://aryido.github.io/posts/leetcode/leetcode127/</link><pubDate>Sun, 09 Oct 2022 23:23:53 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode127/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題第一眼其實看不太出來是 graph 題，但仔細分析會發現是一個單詞，然後能 reach 到的是換一個字母的單詞，就是鄰居；然後要找最短路徑。 難就是難在一開始要把問題轉化成一個 graph!&lt;/p>
&lt;/blockquote></description></item><item><title>23. Merge k Sorted Lists</title><link>https://aryido.github.io/posts/leetcode/leetcode23/</link><pubDate>Mon, 03 Oct 2022 21:54:34 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode23/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是合併 k 個 linked-list，且每個linked-list 都是有序的，最終要合併成一個大的 linked-list ，且也必須是有序的。用 heap 解題還蠻巧妙的，故紀錄一下&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>297. Serialize and Deserialize Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode297/</link><pubDate>Sun, 25 Sep 2022 14:57:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode297/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題使用深度優先 Depth First Traversal 來遍歷，並使用 Pre-Order 方式記錄樹的節點值；Deserialize 時有用到 queue 來儲存節點 value 值。
之前文章也分享過，在想要 Copy Tree 時適合使用Pre-Order。這題有點符合 Copy Tree 的情境，但是是把 value 存下來。&lt;/p>
&lt;/blockquote></description></item><item><title>743. Network Delay Time</title><link>https://aryido.github.io/posts/leetcode/leetcode743/</link><pubDate>Mon, 19 Sep 2022 21:09:18 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode743/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>可以抽象成，計算從&lt;strong>初始節點&lt;/strong>到&lt;strong>最遠節點&lt;/strong>的最優路徑，很標準的 &lt;em>best first search&lt;/em>。 題目常用在水管滲透，或是網路流通，求出初始節點到每一個點到最短時間，然後取其中最大的一個就是需要的時間了。這題就是要你=實作 Dijkstra’s algorithm。&lt;/p>
&lt;/blockquote></description></item><item><title>332. Reconstruct Itinerary</title><link>https://aryido.github.io/posts/leetcode/leetcode332/</link><pubDate>Sat, 17 Sep 2022 10:03:29 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode332/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這種飛航問題基本上都是屬於 Graph 題，題目敘述也很生活化(&lt;del>根本旅行必備知識&lt;/del>)。 因為所有的路徑有且只會被用一次，故是一個 &lt;strong>Euler Circuit&lt;/strong>。&lt;/p>
&lt;p>進一步抽象，可說這題是屬於 &lt;strong>Post-order traversal on Edges&lt;/strong> 問題。 從入口做 &lt;strong>post-order&lt;/strong> ，會是出口先被紀錄，然後再往回 &lt;strong>backtracking&lt;/strong> 回入口，把路上的所有 node 都記下來。 老實說技巧性有點太強，且還是高頻&amp;hellip;。 另外注意英文閱讀，有些單字很重要例如 &lt;em>lexical order&lt;/em>，沒注意到可能會出現錯誤。&lt;/p>
&lt;/blockquote></description></item><item><title>5. Longest Palindromic Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode5/</link><pubDate>Wed, 14 Sep 2022 22:30:14 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道常考題，也因為是 DP，難度也比較高。 看過令人膜拜的神解 Manacher&amp;rsquo;s Algorithm，時間複雜度提升到了 O(n) ，但一般人還是熟悉一般 DP 解就好了&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>973. K Closest Points to Origin</title><link>https://aryido.github.io/posts/leetcode/leetcode973/</link><pubDate>Mon, 12 Sep 2022 20:12:28 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode973/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>類似這種 top k 問題且非樹結構，都可以直接用 Heap 來解題。&lt;/p>
&lt;/blockquote></description></item><item><title>230. Kth Smallest Element in a BST</title><link>https://aryido.github.io/posts/leetcode/leetcode230/</link><pubDate>Sun, 11 Sep 2022 16:12:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode230/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道關於二叉搜索樹 Binary Search Tree 的題目。提示是讓我們用&lt;em>中序遍歷In-Order&lt;/em>來解題。 可以複習一下 DFS 解法的 Pre-Order、In-Order Post-Order。 另外這道題的 Follow up 可以多思考，是假設該 BST 被修改的很頻繁，而且查找第 k 小元素的操作也很頻繁，問如何優化。&lt;/p>
&lt;/blockquote></description></item><item><title>200. Number of Islands</title><link>https://aryido.github.io/posts/leetcode/leetcode200/</link><pubDate>Wed, 07 Sep 2022 20:55:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode200/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>剛開始刷題時就覺得這題很有趣，有 game 的感覺。可以用來複習DFS、BFS。&lt;/p></description></item><item><title>735. Asteroid Collision</title><link>https://aryido.github.io/posts/leetcode/leetcode735/</link><pubDate>Mon, 05 Sep 2022 20:42:24 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode735/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p>
&lt;p>這題雖然好玩但我寫起來真的BUG滿天飛，小行星碰撞 Asteroid Collision。&lt;/p></description></item><item><title>739. Daily Temperatures by Java</title><link>https://aryido.github.io/posts/leetcode/leetcode739/</link><pubDate>Mon, 05 Sep 2022 10:59:38 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode739/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item><item><title>57. Insert Interval</title><link>https://aryido.github.io/posts/leetcode/leetcode57/</link><pubDate>Thu, 01 Sep 2022 11:17:02 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode57/</guid><description>&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item></channel></rss>
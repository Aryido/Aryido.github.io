<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dp on Aryido Tech Note</title><link>https://aryido.github.io/tags/dp/</link><description>Recent content in dp on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 27 Nov 2022 20:26:22 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>410. Split Array Largest Sum - dynamic programming</title><link>https://aryido.github.io/posts/leetcode/leetcode410/</link><pubDate>Sun, 27 Nov 2022 20:26:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題真的蠻難的，一開始看題目我也覺得很繞口，給了一個非負數的 nums 和一個 m 代表把 nums 分成 m 個 group 且 每個 group non-empty 並取 m 個 group 中的最大值。但注意，前面只是代表一種&lt;strong>切法&lt;/strong>而已，我們是要找所有可能&lt;strong>切法&lt;/strong>之中的最小值。看一下 Related Topics 發現可以用 Binary Search 和 DP 求解，也是一道高頻題目。&lt;/p>
&lt;/blockquote></description></item><item><title>877. Stone Game</title><link>https://aryido.github.io/posts/leetcode/leetcode877/</link><pubDate>Fri, 25 Nov 2022 23:36:44 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode877/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>石頭遊戲，兩個人輪流選石頭，Alex 先選，每次只能選開頭或結尾，最終獲得石頭總數多的人獲勝。 乍看之下不好想到可以用 DP 解，但其實可用一個 2D-state 去描述遞迴的狀態。 這題一開始會好奇是因為負評倒讚很多，個人是感覺能從 Game Theory 單純想出這結論也是蠻厲害的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>1143. Longest Common Subsequence</title><link>https://aryido.github.io/posts/leetcode/leetcode1143/</link><pubDate>Tue, 22 Nov 2022 22:46:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1143/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是求最長相同的&lt;strong>子序列&lt;/strong>，可用 Dynamic Programing 來做，最難的還是想出狀態函數。這裡使用 2D-dp ，其中 dp[i][j] 表示 :&lt;/p>
&lt;ul>
&lt;li>text1 的前 i 個字符&lt;/li>
&lt;li>text2 的前 j 個字符&lt;/li>
&lt;/ul>
&lt;p>的最長相同的子序列的字符個數&lt;/p>
&lt;/blockquote></description></item><item><title>139. Word Break</title><link>https://aryido.github.io/posts/leetcode/leetcode139/</link><pubDate>Sat, 12 Nov 2022 22:10:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode139/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>一道很經典的題目，是給定一 string ，能不能分被拆分成 wordDict 裡面的單詞。注意這題，wordDict 裡面的單詞可以重複使用，即單詞使用沒有次數限制，所以 string 可以分成任意段，這就增加了題目的難度。解法蠻多種的，可先從 brute force 下手，再加上暫存優化後，就是蠻標準的 dp 解了，來解一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/posts/leetcode/leetcode78/</link><pubDate>Sun, 06 Nov 2022 22:54:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題很經典的問題 the power set ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選就可以得出。但在程式上卻有點點難度，會被歸類到 Medium 等級。這邊我是使用類似於一種深度優先搜索，但其實也有非遞回式的解法，都可看看並練習。&lt;/p>
&lt;/blockquote></description></item><item><title>Dynamic Programming 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/dynamic-programming1/</link><pubDate>Wed, 02 Nov 2022 21:52:00 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/dynamic-programming1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dynamic Programming 大概算是 leetcode 裡面平均難度最高的章節了，還蠻需要練習的。但在講 DP 之前，我們可以先講 Search，因為 Dynamic Programming 其實就是 Search + Memoization。&lt;/p>
&lt;/blockquote></description></item></channel></rss>
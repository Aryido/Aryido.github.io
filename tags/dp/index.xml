<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dp on Aryido Tech Note</title><link>https://aryido.github.io/tags/dp/</link><description>Recent content in Dp on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Oct 2023 20:10:05 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>Backtrack 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/backtrack/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/backtrack/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Backtrack 是 DFS 的一種形式，基本寫法類似於 TOP DOWN DFS，處理方式就是所謂的窮舉法，將所有可能的結果都找出來；每一個結果都實際看看這樣。換個角度來說，其實這個過程就如同在樹上遍歷 (Tree Traversal) ，而普通的 DFS 是不需要回溯狀態的。 Backtrack 強調了狀態回溯。&lt;/p>
&lt;/blockquote></description></item><item><title>509. Fibonacci Numbers</title><link>https://aryido.github.io/posts/leetcode/leetcode509/</link><pubDate>Mon, 04 Sep 2023 20:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode509/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是非常有名的 Fibonacci 數列，其特徵是除了前兩個數字之外，每個數字等於前兩個數字之和。解法可以帶出一些經典觀念和想法，例如 :&lt;/p>
&lt;ul>
&lt;li>Dynamic Programming&lt;/li>
&lt;li>迭帶 for-loop&lt;/li>
&lt;li>recursion 遞迴&lt;/li>
&lt;/ul>
&lt;p>由於 Fibonacci 數列的時間空間複雜度計算比較特別，加上可以很初步引入很多的思考方式，故雖然這題是 easy ，我還是做個紀錄。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - dynamic programming</title><link>https://aryido.github.io/posts/leetcode/leetcode410/</link><pubDate>Sun, 27 Nov 2022 20:26:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題真的蠻難的，一開始看題目我也覺得很繞口，給了一個非負數的 nums 和一個 m 代表把 nums 分成 m 個 group 且 每個 group non-empty 並取 m 個 group 中的最大值。但注意，前面只是代表一種&lt;strong>切法&lt;/strong>而已，我們是要找所有可能&lt;strong>切法&lt;/strong>之中的最小值。看一下 Related Topics 發現可以用 Binary Search 和 DP 求解，也是一道高頻題目。&lt;/p>
&lt;/blockquote></description></item><item><title>877. Stone Game</title><link>https://aryido.github.io/posts/leetcode/leetcode877/</link><pubDate>Fri, 25 Nov 2022 23:36:44 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode877/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>石頭遊戲，兩個人輪流選石頭，Alex 先選，每次只能選開頭或結尾，最終獲得石頭總數多的人獲勝。 乍看之下不好想到可以用 DP 解，但其實可用一個 2D-state 去描述遞迴的狀態。 這題一開始會好奇是因為負評倒讚很多，個人是感覺能從 Game Theory 單純想出這結論也是蠻厲害的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>1143. Longest Common Subsequence</title><link>https://aryido.github.io/posts/leetcode/leetcode1143/</link><pubDate>Tue, 22 Nov 2022 22:46:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1143/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是求最長相同的&lt;strong>子序列&lt;/strong>，可用 Dynamic Programing 來做，最難的還是想出狀態函數。這裡使用 2D-dp ，其中 dp[i][j] 表示 :&lt;/p>
&lt;ul>
&lt;li>text1 的前 i 個字符&lt;/li>
&lt;li>text2 的前 j 個字符&lt;/li>
&lt;/ul>
&lt;p>的最長相同的子序列的字符個數&lt;/p>
&lt;/blockquote></description></item><item><title>63. Unique Paths II</title><link>https://aryido.github.io/posts/leetcode/leetcode63/</link><pubDate>Sun, 13 Nov 2022 15:22:47 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode63/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 62. Unique Paths 的延伸，能選擇往下或往右走直至終點為止，要求出有多少種可能走法，但多了一個限制，會在路徑中加了一些 obstacle 擋住了某些路徑。是一道典型的 Dynamic Programming - 2D matrix 類型的題目。和爬樓梯等都屬於動態規劃中常見題目，因此也經常會被用於面試之中。&lt;/p>
&lt;/blockquote></description></item><item><title>139. Word Break</title><link>https://aryido.github.io/posts/leetcode/leetcode139/</link><pubDate>Sat, 12 Nov 2022 22:10:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode139/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>一道很經典的題目，是給定一 string ，能不能分被拆分成 wordDict 裡面的單詞。注意這題，wordDict 裡面的單詞可以重複使用，即單詞使用沒有次數限制，所以 string 可以分成任意段，這就增加了題目的難度。解法蠻多種的，可先從 brute force 下手，再加上暫存優化後，就是蠻標準的 dp 解了，來解一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>Dynamic Programming 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/dynamic-programming1/</link><pubDate>Wed, 02 Nov 2022 21:52:00 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/dynamic-programming1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dynamic Programming 大概算是 leetcode 裡面平均難度最高的章節了，還蠻需要練習的。但在講 DP 之前，我們可以先講 Search，因為 Dynamic Programming 其實就是 Search + Memoization。&lt;/p>
&lt;/blockquote></description></item><item><title>5. Longest Palindromic Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode5/</link><pubDate>Wed, 14 Sep 2022 22:30:14 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>最長回文子串 (Longest Palindromic Substring) 是常考題&lt;/strong>。Palindrome 就是正讀反讀都一樣的詞語，比如範例給的 &amp;ldquo;bab&amp;rdquo;、 &amp;ldquo;bb&amp;rdquo; ，實際單字如 &amp;ldquo;level&amp;rdquo; 等等都屬於它。因為較好的解法是 DP 類型，初見就能想到，難度也比較高。一般人能熟悉 Dynamic Programming - 2D matrix 解就好了。(看過令人膜拜的神解 Manacher&amp;rsquo;s Algorithm，時間複雜度提升到了 O(n) &amp;hellip;)&lt;/p>
&lt;/blockquote></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Recursion on Aryido Tech Note</title><link>https://aryido.github.io/tags/recursion/</link><description>Recent content in Recursion on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Sep 2023 21:03:48 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/recursion/index.xml" rel="self" type="application/rss+xml"/><item><title>Merge Sort</title><link>https://aryido.github.io/posts/algorithm/merge-sort/</link><pubDate>Mon, 04 Sep 2023 21:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/merge-sort/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>歸併排序 (Merge Sort)&lt;/strong> 算是比較優秀的排序算法，因為時間複雜度是 &lt;code>O(N log N)&lt;/code>；而選擇排序、冒泡排序、和插入排序時間複雜度則是&lt;code>O(N^2)&lt;/code>。 Merge Sort 的基本思想是&lt;strong>分治法 (Divide and conquer)&lt;/strong>，是將原問題分解為規模較小的子問題，然後逐一解決這些子問題之後，&lt;strong>合併這些子問題的答案&lt;/strong>，並建立原問題的答案。&lt;/p>
&lt;/blockquote></description></item><item><title>509. Fibonacci Numbers</title><link>https://aryido.github.io/posts/leetcode/leetcode509/</link><pubDate>Mon, 04 Sep 2023 20:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode509/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是非常有名的 Fibonacci 數列，其特徵是除了前兩個數字之外，每個數字等於前兩個數字之和。解法可以帶出一些經典觀念和想法，例如 :&lt;/p>
&lt;ul>
&lt;li>Dynamic Programming&lt;/li>
&lt;li>迭帶 for-loop&lt;/li>
&lt;li>recursion 遞迴&lt;/li>
&lt;/ul>
&lt;p>由於 Fibonacci 數列的時間空間複雜度計算比較特別，加上可以很初步引入很多的思考方式，故雖然這題是 easy ，我還是做個紀錄。&lt;/p>
&lt;/blockquote></description></item><item><title>Recursion</title><link>https://aryido.github.io/posts/algorithm/recursion/</link><pubDate>Mon, 04 Sep 2023 20:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/recursion/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>遞迴 (Recursion)&lt;/strong>，通過調用自身函數，有時可以將某個複雜的問題，分解為規模較小的子問題。而 Recursion 也經常和以下演算法配合使用 :&lt;/p>
&lt;ul>
&lt;li>分治法 divide and conquer&lt;/li>
&lt;li>回溯法 backtrack&lt;/li>
&lt;li>動態規劃 dynamic programming&lt;/li>
&lt;/ul>
&lt;p>在實際狀況中，遞迴函數的設計常常很難想像，因為遞迴設計屬於&lt;strong>逆向思維&lt;/strong>，在設計遞迴函數的時候，非常容易被這種層層嵌套搞暈，在這裡簡單給個模板範例講解。&lt;/p>
&lt;/blockquote></description></item><item><title>206. Reverse Linked List</title><link>https://aryido.github.io/posts/leetcode/leetcode206/</link><pubDate>Sun, 27 Aug 2023 19:47:15 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode206/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>反轉 Linked List 是一道經典的題目，可以用分別用 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>指針 (iterative)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>遞迴 (recursive)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>兩種截然不同的風格來解答。個人認為是蠻好的題目，可以多寫幾次，並從各種不同的解答方式來說明思考，故在此筆記。要說簡單也不算，對於 recursive 解法一開始我覺得有點難理解 ! 雖然被歸類在 Easy，但我私心覺得蠻容易打擊第一次做的人的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backtrack on Aryido Tech Note</title><link>https://aryido.github.io/tags/backtrack/</link><description>Recent content in backtrack on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 10 Oct 2023 19:15:23 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/backtrack/index.xml" rel="self" type="application/rss+xml"/><item><title>40. Combination Sum II</title><link>https://aryido.github.io/posts/leetcode/leetcode40/</link><pubDate>Tue, 10 Oct 2023 19:15:23 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode40/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 39. Combination Sum 的進階，給定一個 array 和 target ，找出 candidates 中所有可以使數字和為 target 的組合，但 &lt;strong>candidates 中的每個數字，在每個組合中只能使用一次&lt;/strong>。對比 39. 中的數字是可以重複使用，這題是不能重複使用的，但兩題本質沒有區別，依然是使用 DFS 和 backtrack 思想求解。寫到現在其實已經有感覺到一定的模板了，但多多比較與其他 backtrack 題型的差異才是最重要的。&lt;/p>
&lt;/blockquote></description></item><item><title>39. Combination Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode39/</link><pubDate>Tue, 10 Oct 2023 11:46:49 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode39/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題給了一個 array of &lt;strong>distinct integer&lt;/strong> 以及目標總和 target ，
求用此 array 來組成目標數字的所有組合。像這種要求返回所有符合要求解的題目，基本都是要利用到遞迴，類似的題目有 Subset 、 Permutation 、 Combination 等等，解題套路都是使用 DFS 和 Backtrack 來求得答案。&lt;/p>
&lt;/blockquote></description></item><item><title>Permutations 另解</title><link>https://aryido.github.io/posts/leetcode/leetcode4647/</link><pubDate>Wed, 04 Oct 2023 21:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode4647/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>之前解題利用了&lt;strong>交換 nums 裡面的兩個數字&lt;/strong>的方式，這次換另一種寫法，可單純使用 backtracking 來解題。故把 leetcode46 和 leetcode47 重新解答一遍。&lt;/p>
&lt;/blockquote></description></item><item><title>47. Permutations II</title><link>https://aryido.github.io/posts/leetcode/leetcode47/</link><pubDate>Wed, 04 Oct 2023 20:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode47/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 46. Permutations 的進階版，現在數字會有重複(duplicate) 。這邊一樣使用 DFS 加上 Backtrack 來求解。從數學上來說，&lt;code>n&lt;/code> 個 element ，且將相同的事物歸為一組, 可歸成 &lt;em>k&lt;/em> 組, 且每組有 &lt;code>m_i&lt;/code> 個，其 Permutation 一共有 &lt;code>n!/(m_1!m_2!...m_k!)&lt;/code> 種排序，為高中數學題中，需要思考下的題目；用程式模擬這個過程也有難度，故被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>46. Permutations</title><link>https://aryido.github.io/posts/leetcode/leetcode46/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode46/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是一道經典 distinct integers 的全排列問題，這邊使用 DFS 加上 Backtrack 來求解。從數學上來說，n 個 element 的 Permutation 一共有 n! 種排序，思考起來算蠻簡單的，但要用程式模擬這個推導過程，卻是有點難度的，因此被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>Backtrack 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/backtrack/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/backtrack/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Backtrack 是 DFS 的一種形式，基本寫法類似於 TOP DOWN DFS，處理方式就是所謂的窮舉法，將所有可能的結果都找出來；每一個結果都實際看看這樣。換個角度來說，其實這個過程就如同在樹上遍歷 (Tree Traversal) ，而普通的 DFS 是不需要回溯狀態的。 Backtrack 強調了狀態回溯。&lt;/p>
&lt;/blockquote></description></item><item><title>797. All Paths From Source to Target</title><link>https://aryido.github.io/posts/leetcode/leetcode797/</link><pubDate>Wed, 05 Apr 2023 17:00:37 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode797/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題給了我們一個無環有向圖 (directed acyclic graph)(DAG) 。有 N 個 node ，要找出所有可能的從 &lt;code>node 0&lt;/code> 到 &lt;code>node N-1&lt;/code> 的路徑。像這種需要走到終點，且在每一次新的遞迴時，都要把當前路徑記錄下來，其本質都是&lt;strong>深度遍歷 graph&lt;/strong> ，再加上 &lt;strong>backtrack 回溯狀態&lt;/strong>。是經典的 dfs 的題目。&lt;/p>
&lt;/blockquote></description></item></channel></rss>
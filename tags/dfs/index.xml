<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DFS on Aryido Tech Note</title><link>https://aryido.github.io/tags/dfs/</link><description>Recent content in DFS on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 17 Oct 2023 23:01:42 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml"/><item><title>90. Subsets II</title><link>https://aryido.github.io/posts/leetcode/leetcode90/</link><pubDate>Tue, 17 Oct 2023 23:01:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode90/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 78. Subsets 的進階版，現在數字會有重複(duplicate)。這邊使用 Backtrack 模板來求解。這個題目還有要注意的地方，就是 array 不一定是順序的，例如 test case: &lt;code>[4,4,4,1,4]&lt;/code>，這範例在我們去除重複答案的時候，若沒注意到有亂序的可能性，高機率會出錯。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/posts/leetcode/leetcode78/</link><pubDate>Tue, 17 Oct 2023 22:11:25 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>很經典的問題 : &lt;strong>冪集 the power set&lt;/strong> ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選排列組合，就可以得出答案。但在程式上要實現卻有一點點難度，故會被歸類到 Medium 等級。這邊使用 Backtrack 模板來解題。&lt;/p>
&lt;/blockquote></description></item><item><title>40. Combination Sum II</title><link>https://aryido.github.io/posts/leetcode/leetcode40/</link><pubDate>Tue, 10 Oct 2023 19:15:23 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode40/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 39. Combination Sum 的進階，給定一個 array 和 target ，找出 candidates 中所有可以使數字和為 target 的組合，但 &lt;strong>candidates 中的每個數字，在每個組合中只能使用一次&lt;/strong>。對比 39. 中的數字是可以重複使用，這題是不能重複使用的，但兩題本質沒有區別，依然是使用 DFS 和 backtrack 思想求解。寫到現在其實已經有感覺到一定的模板了，但多多比較與其他 backtrack 題型的差異才是最重要的。&lt;/p>
&lt;/blockquote></description></item><item><title>39. Combination Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode39/</link><pubDate>Tue, 10 Oct 2023 11:46:49 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode39/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題給了一個 array of &lt;strong>distinct integer&lt;/strong> 以及目標總和 target ，
求用此 array 來組成目標數字的所有組合。像這種要求返回所有符合要求解的題目，基本都是要利用到遞迴，類似的題目有 Subset 、 Permutation 、 Combination 等等，解題套路都是使用 DFS 和 Backtrack 來求得答案。&lt;/p>
&lt;/blockquote></description></item><item><title>Permutations 另解</title><link>https://aryido.github.io/posts/leetcode/leetcode4647/</link><pubDate>Wed, 04 Oct 2023 21:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode4647/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>之前解題利用了&lt;strong>交換 nums 裡面的兩個數字&lt;/strong>的方式，這次換另一種寫法，&lt;strong>做出一個 inner list 收集可能的結果&lt;/strong>。基本解題思想都還是 Backtracking ，故把 leetcode46 和 leetcode47 重新解答一遍。&lt;/p>
&lt;/blockquote></description></item><item><title>47. Permutations II</title><link>https://aryido.github.io/posts/leetcode/leetcode47/</link><pubDate>Wed, 04 Oct 2023 20:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode47/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 46. Permutations 的進階版，現在數字會有重複(duplicate) 。這邊一樣使用 DFS 加上 Backtrack 來求解。從數學上來說，&lt;code>n&lt;/code> 個 element ，且將相同的事物歸為一組, 可歸成 &lt;em>k&lt;/em> 組, 且每組有 &lt;code>m_i&lt;/code> 個，其 Permutation 一共有 &lt;code>n!/(m_1!m_2!...m_k!)&lt;/code> 種排序，為高中數學題中，需要思考下的題目；用程式模擬這個過程也有難度，故被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>46. Permutations</title><link>https://aryido.github.io/posts/leetcode/leetcode46/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode46/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是一道經典 distinct integers 的全排列問題，這邊使用 DFS 加上 Backtrack 來求解。從數學上來說，n 個 element 的 Permutation 一共有 n! 種排序，思考起來算蠻簡單的，但要用程式模擬這個推導過程，卻是有點難度的，因此被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>543. Diameter of Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode543/</link><pubDate>Sun, 16 Apr 2023 15:59:57 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode543/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是要求 Binary Tree 的 diameter ，要注意一下 diameter 的定義並&lt;strong>不等於深度&lt;/strong> ! 根據題目中的例子，可了解所謂 diameter 的定義，是兩點之間的最遠距離。雖然 Binary Tree 的 diameter 並不等於深度，但是和深度有非常大的關係，所以解法用 DFS 是比較直觀的想法。(雖然題目難度說是 easy，但我個人覺得應該算初階 medium&amp;hellip;)&lt;/p>
&lt;/blockquote></description></item><item><title>79. Word Search</title><link>https://aryido.github.io/posts/leetcode/leetcode79/</link><pubDate>Mon, 20 Mar 2023 22:45:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode79/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給定一個 board 以及 一個 word ，我們要判斷的 board 上是否可以連線出 word。這題是蠻典型的 graph 類題目，用 BFS 或 DFS 解題都行，但用深度優先 DFS 來解題會比較好一些(可以先思考一下為什麼)。解題流程還蠻制式化的，是熟練 graph 類型的練習好題目 XD。&lt;/p>
&lt;/blockquote></description></item><item><title>332. Reconstruct Itinerary</title><link>https://aryido.github.io/posts/leetcode/leetcode332/</link><pubDate>Sat, 17 Sep 2022 10:03:29 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode332/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這種飛航問題基本上都是屬於 Graph 題，題目敘述也很生活化(&lt;del>根本旅行必備知識&lt;/del>)。 因為所有的路徑有且只會被用一次，故是一個 &lt;strong>Euler Circuit&lt;/strong>。&lt;/p>
&lt;p>進一步抽象，可說這題是屬於 &lt;strong>Post-order traversal on Edges&lt;/strong> 問題。 從入口做 &lt;strong>post-order&lt;/strong> ，會是出口先被紀錄，然後再往回 &lt;strong>backtracking&lt;/strong> 回入口，把路上的所有 node 都記下來。 老實說技巧性有點太強，且還是高頻&amp;hellip;。 另外注意英文閱讀，有些單字很重要例如 &lt;em>lexical order&lt;/em>，沒注意到可能會出現錯誤。&lt;/p>
&lt;/blockquote></description></item><item><title>Graph 介紹</title><link>https://aryido.github.io/posts/data-structure/graph/</link><pubDate>Tue, 13 Sep 2022 21:37:08 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/graph/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Graph 用於表示物體與物體之間存在某種關係的結構，是內存中不一定連續的資料，每個節點會一個或多個 Reference 指向其他節點&lt;/p>
&lt;ul>
&lt;li>可能有環&lt;/li>
&lt;li>分無向圖和有向圖&lt;/li>
&lt;li>沒有固定入口&lt;/li>
&lt;li>可能有多個入口&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>230. Kth Smallest Element in a BST</title><link>https://aryido.github.io/posts/leetcode/leetcode230/</link><pubDate>Sun, 11 Sep 2022 16:12:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode230/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道關於二叉搜索樹 Binary Search Tree 的題目。提示是讓我們用&lt;em>中序遍歷In-Order&lt;/em>來解題。 可以複習一下 DFS 解法的 Pre-Order、In-Order Post-Order。 另外這道題的 Follow up 可以多思考，是假設該 BST 被修改的很頻繁，而且查找第 k 小元素的操作也很頻繁，問如何優化。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search Tree</title><link>https://aryido.github.io/posts/data-structure/binary-search-tree/</link><pubDate>Sun, 11 Sep 2022 14:53:52 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/binary-search-tree/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>二元搜尋樹（英語：Binary Search Tree），也稱為有序二元樹（ordered binary tree）或排序二元樹（sorted binary tree）。 從 wiki 上得到的時間與空間複雜度 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">演算法&lt;/th>
&lt;th style="text-align:center">平均&lt;/th>
&lt;th style="text-align:center">最差&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">空間&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">搜尋&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">插入&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">刪除&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/blockquote></description></item><item><title>200. Number of Islands</title><link>https://aryido.github.io/posts/leetcode/leetcode200/</link><pubDate>Wed, 07 Sep 2022 20:55:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode200/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>剛開始刷題時就覺得這題很有趣，有 game 的感覺。可以用來複習DFS、BFS。&lt;/p></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>protobuf on Aryido Tech Note</title><link>https://aryido.github.io/tags/protobuf/</link><description>Recent content in protobuf on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 May 2024 22:10:30 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/protobuf/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf - 序列化反序列化詳解</title><link>https://aryido.github.io/posts/data-structure/protobuf-serialization/</link><pubDate>Wed, 01 May 2024 22:10:30 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-serialization/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 &lt;strong>.proto&lt;/strong> 檔案，就可以生成&lt;strong>不同的程式語言&lt;/strong>來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :&lt;/p>
&lt;ul>
&lt;li>Varint Encoding&lt;/li>
&lt;li>Zigzag Encoding&lt;/li>
&lt;li>Wire Type 類型&lt;/li>
&lt;li>T-L-V 儲存方式&lt;/li>
&lt;/ul>
&lt;p>熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf - Encoding 結構</title><link>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</link><pubDate>Sun, 28 Apr 2024 17:56:27 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>隨者網路傳輸、頻寬與硬體的設備的改善和增強，能傳遞資料量也越來越大、越來越複雜，這時我們也不再只是追求能夠將資料傳遞完成，而是更加要求&lt;strong>短時內傳遞大量的資料&lt;/strong>，故勢必會需要強化&lt;strong>序列化&lt;/strong>和&lt;strong>壓縮&lt;/strong>的技術。這篇會介紹 Protobuf 編碼後的 byte array 結構，以及會這樣設計的思路，當有了基本的認識後，就會明白 Protobuf 為何它可以比 JSON、XML 傳輸效率更高，更能壓縮資料，實現高效率。&lt;/p>
&lt;/blockquote></description></item><item><title>Varint &amp; Zigzag Encoding</title><link>https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/</link><pubDate>Sat, 27 Apr 2024 16:02:33 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>蠻多 coding 語言在一般情況下是使用 &lt;code>32 bits&lt;/code> 的空間來儲存整數的，例如 Java 的 int，範圍是 &lt;code>-2147483648 ~ 2147483647&lt;/code>，大約正負21億。但是現實世界中，較小的數字往往比較常出現，大約幾十到幾十萬是最多最常出現的，如果只是要儲存或傳輸這樣的一個小數字，卻每次都需要用到 32 bits 的空間，其實有點浪費，這是有機會優化的 !&lt;/p>
&lt;p>Varint 和 Zigzag 演算法就是要處理這種問題，&lt;strong>讓值小的數字，可以用較少的 byte 數量表示，而達到資料壓縮目的&lt;/strong>，著名的資料傳輸格式 &lt;strong>Protobuf&lt;/strong> 也是通過 Varint 和 Zigzag ，來大幅減少了資料佔用的空間。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf 簡介</title><link>https://aryido.github.io/posts/data-structure/protobuf/</link><pubDate>Fri, 26 Apr 2024 00:44:35 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Protobuf 全稱 Protocol Buffers ，是一種輕量級的資料交換格式，最初是由 Google 開發的「&lt;strong>可擴展的序列化資料結構&lt;/strong>」，現已成為一個開源項目，其語⾔中⽴且平台無關，適合高性能且對響應速度有高要求的資料傳輸場景；也因為有&lt;strong>資料壓縮&lt;/strong>的能力，故也可用於資料儲存。Protobuf 的核心思想是&lt;strong>先定義好 data schema&lt;/strong> ，然後可根據所需的語言&lt;strong>生成對應的 code base&lt;/strong>，方便使用者操作 :「序列化寫入、反序列化讀取」。&lt;/p>
&lt;p>Profobuf 需要注意的缺點是為&lt;strong>二進制格式&lt;/strong>，故編碼之後不具有可讀性，需要反序列化後才能看得懂資料內容 ; 雖然是個好東西，但並非是個用來完全取代 JSON 的解決方案，JSON 仍有其可讀性高、易操作及通用性高等優點，在多數 API 設計的場景之下，JSON 仍然是最好的選擇。&lt;/p>
&lt;/blockquote></description></item></channel></rss>
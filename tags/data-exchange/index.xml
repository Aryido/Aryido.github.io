<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>data-exchange on Aryido Tech Note</title><link>https://aryido.github.io/tags/data-exchange/</link><description>Recent content in data-exchange on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 17 Aug 2024 23:18:06 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/data-exchange/index.xml" rel="self" type="application/rss+xml"/><item><title>GCP - Pub/Sub 概述 I - 架構</title><link>https://aryido.github.io/posts/google-cloud/pubsub-1/</link><pubDate>Sat, 17 Aug 2024 23:18:06 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/pubsub-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>SQS + SNS&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Service Bus Messaging&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 &lt;a href="https://cloud.google.com/pubsub/sla?hl=en">Pub/Sub service level agreement (SLA)&lt;/a>，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf - 序列化反序列化詳解</title><link>https://aryido.github.io/posts/data-structure/protobuf-serialization/</link><pubDate>Wed, 01 May 2024 22:10:30 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-serialization/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 &lt;strong>.proto&lt;/strong> 檔案，就可以生成&lt;strong>不同的程式語言&lt;/strong>來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :&lt;/p>
&lt;ul>
&lt;li>Varint Encoding&lt;/li>
&lt;li>Zigzag Encoding&lt;/li>
&lt;li>Wire Type 類型&lt;/li>
&lt;li>T-L-V 儲存方式&lt;/li>
&lt;/ul>
&lt;p>熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf - Encoding 結構</title><link>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</link><pubDate>Sun, 28 Apr 2024 17:56:27 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>隨者網路傳輸、頻寬與硬體的設備的改善和增強，能傳遞資料量也越來越大、越來越複雜，這時我們也不再只是追求能夠將資料傳遞完成，而是更加要求&lt;strong>短時內傳遞大量的資料&lt;/strong>，故勢必會需要強化&lt;strong>序列化&lt;/strong>和&lt;strong>壓縮&lt;/strong>的技術。這篇會介紹 Protobuf 編碼後的 byte array 結構，以及會這樣設計的思路，當有了基本的認識後，就會明白 Protobuf 為何它可以比 JSON、XML 傳輸效率更高，更能壓縮資料，實現高效率。&lt;/p>
&lt;/blockquote></description></item><item><title>Varint &amp; Zigzag Encoding</title><link>https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/</link><pubDate>Sat, 27 Apr 2024 16:02:33 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>蠻多 coding 語言在一般情況下是使用 &lt;code>32 bits&lt;/code> 的空間來儲存整數的，例如 Java 的 int，範圍是 &lt;code>-2147483648 ~ 2147483647&lt;/code>，大約正負21億。但是現實世界中，較小的數字往往比較常出現，大約幾十到幾十萬是最多最常出現的，如果只是要儲存或傳輸這樣的一個小數字，卻每次都需要用到 32 bits 的空間，其實有點浪費，這是有機會優化的 !&lt;/p>
&lt;p>Varint 和 Zigzag 演算法就是要處理這種問題，&lt;strong>讓值小的數字，可以用較少的 byte 數量表示，而達到資料壓縮目的&lt;/strong>，著名的資料傳輸格式 &lt;strong>Protobuf&lt;/strong> 也是通過 Varint 和 Zigzag ，來大幅減少了資料佔用的空間。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf 簡介</title><link>https://aryido.github.io/posts/data-structure/protobuf/</link><pubDate>Fri, 26 Apr 2024 00:44:35 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Protobuf 全稱 Protocol Buffers ，是一種輕量級的資料交換格式，最初是由 Google 開發的「&lt;strong>可擴展的序列化資料結構&lt;/strong>」，現已成為一個開源項目，其語⾔中⽴且平台無關，適合高性能且對響應速度有高要求的資料傳輸場景；也因為有&lt;strong>資料壓縮&lt;/strong>的能力，故也可用於資料儲存。Protobuf 的核心思想是&lt;strong>先定義好 data schema&lt;/strong> ，然後可根據所需的語言&lt;strong>生成對應的 code base&lt;/strong>，方便使用者操作 :「序列化寫入、反序列化讀取」。&lt;/p>
&lt;p>Profobuf 需要注意的缺點是為&lt;strong>二進制格式&lt;/strong>，故編碼之後不具有可讀性，需要反序列化後才能看得懂資料內容 ; 雖然是個好東西，但並非是個用來完全取代 JSON 的解決方案，JSON 仍有其可讀性高、易操作及通用性高等優點，在多數 API 設計的場景之下，JSON 仍然是最好的選擇。&lt;/p>
&lt;/blockquote></description></item><item><title>Avro 簡介</title><link>https://aryido.github.io/not-yet-finished/avro/</link><pubDate>Sun, 23 Apr 2023 15:27:54 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Avro 是一個 data serialization 框架 ，為 Apache Hadoop 下的一個子項目，定義一個可跨多種程式語言和平台的&lt;strong>傳輸資料格式&lt;/strong>。Avro 可使用 JSON 格式來描述 data structure，並且支持&lt;strong>架構演進&lt;/strong>，保持向後/向前的相容性。 Avro 也提供了編解碼和二進制格式，使得在高吞吐量的應用場景中非常有用且高效。&lt;/p>
&lt;/blockquote></description></item></channel></rss>
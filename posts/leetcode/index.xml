<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aryido Tech Note</title><link>https://aryido.github.io/posts/leetcode/</link><description>Recent content on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 27 Aug 2023 19:47:15 +0800</lastBuildDate><atom:link href="https://aryido.github.io/posts/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>206. Reverse Linked List</title><link>https://aryido.github.io/posts/leetcode/leetcode206/</link><pubDate>Sun, 27 Aug 2023 19:47:15 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode206/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>反轉 Linked List 是一道經典的題目，可以用分別用 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>指針 (iterative)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>遞迴 (recursive)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>兩種截然不同的風格來解答。個人認為是蠻好的題目，可以多寫幾次，並從各種不同的解答方式來說明思考，故在此筆記。要說簡單也不算，對於 recursive 解法一開始我覺得有點難理解 ! 雖然被歸類在 Easy，但我私心覺得蠻容易打擊第一次做的人的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>49. Group Anagrams</title><link>https://aryido.github.io/posts/leetcode/leetcode49/</link><pubDate>Sun, 04 Jun 2023 13:53:53 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode49/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>所謂的兩字串互為 Anagrams ，意思就是兩個字串中，&lt;strong>字母出現的次數都一樣，只是位置不同&lt;/strong>，比如題目說的 ate 、 eat 、 tea 它們就都互為 Anagrams 。如何判斷兩字串是否互為 Anagrams 是關鍵解題點，這題雖然歸為 Medium ，但我認為是 easy 而已，主要是要:&lt;/p>
&lt;ul>
&lt;li>熟悉一些 java 內建常用的字串處理 function ，寫起來會比較簡潔。&lt;/li>
&lt;li>想到使用 map 結構來儲存分組資料。&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>543. Diameter of Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode543/</link><pubDate>Sun, 16 Apr 2023 15:59:57 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode543/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是要求 Binary Tree 的 diameter ，要注意一下 diameter 的定義並&lt;strong>不等於深度&lt;/strong> ! 根據題目中的例子，可了解所謂 diameter 的定義，是兩點之間的最遠距離。雖然 Binary Tree 的 diameter 並不等於深度，但是和深度有非常大的關係，所以解法用 DFS 是比較直觀的想法。(雖然題目難度說是 easy，但我個人覺得應該算初階 medium&amp;hellip;)&lt;/p>
&lt;/blockquote></description></item><item><title>138. Copy List with Random Pointer</title><link>https://aryido.github.io/posts/leetcode/leetcode138/</link><pubDate>Tue, 11 Apr 2023 23:40:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode138/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>deep copy 是程式初新手常會有疑問的地方，這邊剛好可以藉由解題來複習指標的概念。另外這題有很巧妙的解法，就是利用 HashMap 來建立原 node 和拷貝 node 之間的映射 ! 也可以使用遞迴的解法，寫起來相當的簡潔。&lt;/p>
&lt;/blockquote></description></item><item><title>295. Find Median from Data Stream</title><link>https://aryido.github.io/posts/leetcode/leetcode295/</link><pubDate>Sat, 08 Apr 2023 19:56:55 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode295/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題為一個設計題，給了一個 Data Stream，希望設計一個 class 能夠支援連續的 operation，並找出該 Stream 目前的中位數。注意 Data Stream 中的 Data 是無序的且可以為負數，所以我們要做的第一件事是讓&lt;strong>每一次 data 輸入進來，都要讓其有序&lt;/strong>。這裡介紹的解法十分巧妙，&lt;strong>使用 maxHeap 和 minHeap 來解決問題&lt;/strong>，這樣中位數的計算便只要看 maxHeap 的最大值和 minHeap 的最小值來判斷。&lt;/p>
&lt;/blockquote></description></item><item><title>797. All Paths From Source to Target</title><link>https://aryido.github.io/posts/leetcode/leetcode797/</link><pubDate>Wed, 05 Apr 2023 17:00:37 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode797/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題給了我們一個無環有向圖 (directed acyclic graph)(DAG) 。有 N 個 node ，要找出所有可能的從 &lt;code>node 0&lt;/code> 到 &lt;code>node N-1&lt;/code> 的路徑。像這種需要走到終點，且在每一次新的遞迴時，都要把當前路徑記錄下來，其本質都是&lt;strong>深度遍歷 graph&lt;/strong> ，再加上 &lt;strong>backtrack 回溯狀態&lt;/strong>。是經典的 dfs 的題目。&lt;/p>
&lt;/blockquote></description></item><item><title>79. Word Search</title><link>https://aryido.github.io/posts/leetcode/leetcode79/</link><pubDate>Mon, 20 Mar 2023 22:45:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode79/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給定一個 board 以及 一個 word ，我們要判斷的 board 上是否可以連線出 word。這題是蠻典型的 graph 類題目，用 BFS 或 DFS 解題都行，但用深度優先 DFS 來解題會比較好一些(可以先思考一下為什麼)。解題流程還蠻制式化的，是熟練 graph 類型的練習好題目 XD。&lt;/p>
&lt;/blockquote></description></item><item><title>76. Minimum Window Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode76/</link><pubDate>Sat, 11 Mar 2023 12:13:17 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode76/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給了我們一個字符 &lt;em>s&lt;/em>，還有一個目標字符 &lt;em>t&lt;/em>，要在 &lt;em>s&lt;/em> 中找到一個 &lt;strong>minimum window substring&lt;/strong> 使得其包含了 &lt;em>t&lt;/em> 中的所有的字母。整體看起來題目難在 :&lt;/p>
&lt;ul>
&lt;li>限制了時間複雜度為 &lt;em>O(n + m)&lt;/em>&lt;/li>
&lt;li>第一次要寫出 bug free 有點困難&lt;/li>
&lt;/ul>
&lt;p>故備標註為 &lt;strong>hard&lt;/strong> ，但整體思路上並不算太難，值得品味一下 !&lt;/p>
&lt;/blockquote></description></item><item><title>763. Partition Labels</title><link>https://aryido.github.io/posts/leetcode/leetcode763/</link><pubDate>Sun, 05 Mar 2023 22:48:40 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode763/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題給了一個 string，然後要盡可能將 string 切割越多塊 sub-string 越好( as many parts as possible)，其中條件是&lt;strong>每個 char，最多只能出現在自己的 sub-string 中&lt;/strong>。 即 :&lt;/p>
&lt;ul>
&lt;li>分割字串使字串中的每個字母在該分割段落中出現達到最多次。&lt;/li>
&lt;/ul>
&lt;p>題目理解是和自己想解法是比較花時間的，看過解答後都可以很快寫出來。&lt;/p>
&lt;/blockquote></description></item><item><title>18. 4Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode18/</link><pubDate>Wed, 15 Feb 2023 22:17:40 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode18/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Leetcode 幾個數字題，15、16、18，基本上套路都是一樣的(&lt;del>甚至可以預期可能還會出 5 Sum&amp;hellip;&lt;/del>)，整體的解法都差不多，可以一起複習，重點仍然是 :&lt;/p>
&lt;ol>
&lt;li>排序 array&lt;/li>
&lt;li>避免的重複項&lt;/li>
&lt;/ol>
&lt;p>以 3Sum 此基礎上，再加了一個循環而已。&lt;/p>
&lt;/blockquote></description></item><item><title>15. 3Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode15/</link><pubDate>Thu, 09 Feb 2023 22:56:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode15/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是 Two Sum 的一種另類進階，從 nums 中找出和為 &lt;code>0&lt;/code> 的三個 element ，並組成 &lt;strong>List of list&lt;/strong> 。特別注意，不能有兩個內容一樣的 list。因為整個題目並沒有對 &lt;em>nums&lt;/em> 的 &lt;em>index&lt;/em> 有任何要求，故可以&lt;strong>把 nums 排序&lt;/strong>，為解題拓開另一種思路。&lt;/p>
&lt;/blockquote></description></item><item><title>16. 3Sum Closest</title><link>https://aryido.github.io/posts/leetcode/leetcode16/</link><pubDate>Wed, 08 Feb 2023 21:56:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode16/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題跟 15 題相似，又增加了些許難度。題目敘述一樣也很簡單 : 求 nums 內最接近 &lt;em>target&lt;/em> 值的三數和。優化關鍵點一樣是，&lt;em>把 nums 排序&lt;/em>，這樣就可以確定指針滑動方向。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/leetcode/16.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/leetcode/16.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://aryido.github.io/posts/leetcode/leetcode26/</link><pubDate>Sun, 25 Dec 2022 15:05:58 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode26/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題要我們從&lt;strong>有序數組&lt;/strong>中去除重複項，題目難度雖然被歸為 easy 等級，但在&lt;strong>條件限制&lt;/strong>上的討論，蠻多東西可以釐清討論的。 英文方面寫得蠻長，記得要看到最後因為有寫一些限制如 :&lt;/p>
&lt;ul>
&lt;li>&lt;em>O(1)&lt;/em> extra memory&lt;/li>
&lt;li>The relative order of the elements should be kept the same.&lt;/li>
&lt;/ul>
&lt;p>所以&lt;strong>不能用 Set 或另開 array 去寫&lt;/strong>。另外也花了些篇幅去說明，只要原 array 前面長度部分內，有把所有不重複數字列出來就好，不需要在意後面 array 的元素和 array 的長度。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - binary search</title><link>https://aryido.github.io/posts/leetcode/leetcode410-2/</link><pubDate>Sun, 11 Dec 2022 18:32:09 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹用 dp 方式把這題給解了，但看一下 Related Topics 發現也可以用 Binary Search 求解，上網參考大神們的解法，感覺特別巧妙。因為這題可用 dp 和 Binary Search，也變成是一道高頻難題。
這邊記錄一下大神們的想法。&lt;/p>
&lt;/blockquote></description></item><item><title>47. Permutations II</title><link>https://aryido.github.io/posts/leetcode/leetcode47/</link><pubDate>Sun, 04 Dec 2022 18:41:26 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode47/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 46. Permutations 的進階，現在有 duplicate 數字，一樣使用 backtrack 來求解。從數學上來說，&lt;em>n&lt;/em> 個 element ，且將相同的事物歸為一組, 可歸成&lt;em>k&lt;/em>組, 且每組有&lt;em>m_i&lt;/em>個，其 Permutation 一共有 &lt;em>n!/(m_1!m_2!&amp;hellip;m_k!)&lt;/em> 種排序，高中數學題需要思考下的基礎題，要用程式模擬這個過程也有點難度，被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>46. Permutations</title><link>https://aryido.github.io/posts/leetcode/leetcode46/</link><pubDate>Wed, 30 Nov 2022 23:38:55 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode46/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是一道經典 distinct integers 的全排列問題，這邊使用 DFS 加上 Backtrack 來求解。從數學上來說，n 個 element 的 Permutation 一共有 n! 種排序，思考起來算蠻簡單的，但要用程式模擬這個推導過程，卻是有點難度的，因此被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - dynamic programming</title><link>https://aryido.github.io/posts/leetcode/leetcode410/</link><pubDate>Sun, 27 Nov 2022 20:26:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題真的蠻難的，一開始看題目我也覺得很繞口，給了一個非負數的 nums 和一個 m 代表把 nums 分成 m 個 group 且 每個 group non-empty 並取 m 個 group 中的最大值。但注意，前面只是代表一種&lt;strong>切法&lt;/strong>而已，我們是要找所有可能&lt;strong>切法&lt;/strong>之中的最小值。看一下 Related Topics 發現可以用 Binary Search 和 DP 求解，也是一道高頻題目。&lt;/p>
&lt;/blockquote></description></item><item><title>877. Stone Game</title><link>https://aryido.github.io/posts/leetcode/leetcode877/</link><pubDate>Fri, 25 Nov 2022 23:36:44 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode877/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>石頭遊戲，兩個人輪流選石頭，Alex 先選，每次只能選開頭或結尾，最終獲得石頭總數多的人獲勝。 乍看之下不好想到可以用 DP 解，但其實可用一個 2D-state 去描述遞迴的狀態。 這題一開始會好奇是因為負評倒讚很多，個人是感覺能從 Game Theory 單純想出這結論也是蠻厲害的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>1143. Longest Common Subsequence</title><link>https://aryido.github.io/posts/leetcode/leetcode1143/</link><pubDate>Tue, 22 Nov 2022 22:46:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1143/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是求最長相同的&lt;strong>子序列&lt;/strong>，可用 Dynamic Programing 來做，最難的還是想出狀態函數。這裡使用 2D-dp ，其中 dp[i][j] 表示 :&lt;/p>
&lt;ul>
&lt;li>text1 的前 i 個字符&lt;/li>
&lt;li>text2 的前 j 個字符&lt;/li>
&lt;/ul>
&lt;p>的最長相同的子序列的字符個數&lt;/p>
&lt;/blockquote></description></item><item><title>63. Unique Paths II</title><link>https://aryido.github.io/posts/leetcode/leetcode63/</link><pubDate>Sun, 13 Nov 2022 15:22:47 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode63/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 62. Unique Paths 的延伸，在路徑中加了一些 obstacle ，用 Dynamic Programming 二維的 dp 數組來解題&lt;/p>
&lt;/blockquote></description></item><item><title>139. Word Break</title><link>https://aryido.github.io/posts/leetcode/leetcode139/</link><pubDate>Sat, 12 Nov 2022 22:10:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode139/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>一道很經典的題目，是給定一 string ，能不能分被拆分成 wordDict 裡面的單詞。注意這題，wordDict 裡面的單詞可以重複使用，即單詞使用沒有次數限制，所以 string 可以分成任意段，這就增加了題目的難度。解法蠻多種的，可先從 brute force 下手，再加上暫存優化後，就是蠻標準的 dp 解了，來解一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/posts/leetcode/leetcode78/</link><pubDate>Sun, 06 Nov 2022 22:54:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題很經典的問題 the power set ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選就可以得出。但在程式上卻有點點難度，會被歸類到 Medium 等級。這邊我是使用類似於一種深度優先搜索，但其實也有非遞回式的解法，都可看看並練習。&lt;/p>
&lt;/blockquote></description></item><item><title>560. Subarray Sum Equals K</title><link>https://aryido.github.io/posts/leetcode/leetcode560/</link><pubDate>Sun, 23 Oct 2022 11:03:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode560/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題我看起來也是很技巧性的題目，一開始要把 subarray 的特性掌握的淋漓盡致，並且想到用 hashmap 來建立快速查找關係，真的有點困難&amp;hellip;但也是這道題的魅力吧 ! 基本上 hashmap 題目大概都會偏向這種步驟應用，多注意可以讓自己視野開闊。&lt;/p></description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://aryido.github.io/posts/leetcode/leetcode1011/</link><pubDate>Sat, 15 Oct 2022 19:18:43 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1011/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題是 Google 面試題，在 Hide Hint 中表示可以使用 binary-search 解決，剛開始覺得蠻 tricky 的，但仔細思考會覺得 binary-search 很符合這題目。&lt;/p></description></item><item><title>127. Word Ladder</title><link>https://aryido.github.io/posts/leetcode/leetcode127/</link><pubDate>Sun, 09 Oct 2022 23:23:53 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode127/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題第一眼其實看不太出來是 graph 題，但仔細分析會發現是一個單詞，然後能 reach 到的是換一個字母的單詞，就是鄰居；然後要找最短路徑。 難就是難在一開始要把問題轉化成一個 graph!&lt;/p>
&lt;/blockquote></description></item><item><title>23. Merge k Sorted Lists</title><link>https://aryido.github.io/posts/leetcode/leetcode23/</link><pubDate>Mon, 03 Oct 2022 21:54:34 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode23/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題需求是要合併 k 個 linked-list 成一個大的 linked-list，&lt;strong>每個 linked-list 都是有序的&lt;/strong>，且大的 linked-list 也必須是有序的，是 LeetCode21. Merge Two Sorted Lists 的進階題，但本題可用 min heap 解題，還蠻巧妙的，故紀錄一下。&lt;/p>
&lt;/blockquote></description></item><item><title>297. Serialize and Deserialize Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode297/</link><pubDate>Sun, 25 Sep 2022 14:57:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode297/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題使用深度優先 Depth First Traversal 來遍歷，並使用 Pre-Order 方式記錄樹的節點值；Deserialize 時有用到 queue 來儲存節點 value 值。
之前文章也分享過，在想要 Copy Tree 時適合使用Pre-Order。這題有點符合 Copy Tree 的情境，但是是把 value 存下來。&lt;/p>
&lt;/blockquote></description></item><item><title>743. Network Delay Time</title><link>https://aryido.github.io/posts/leetcode/leetcode743/</link><pubDate>Mon, 19 Sep 2022 21:09:18 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode743/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>可以抽象成，計算從&lt;strong>初始節點&lt;/strong>到&lt;strong>最遠節點&lt;/strong>的最優路徑，很標準的 &lt;em>best first search&lt;/em>。 題目常用在水管滲透，或是網路流通，求出初始節點到每一個點到最短時間，然後取其中最大的一個就是需要的時間了。這題就是要你=實作 Dijkstra’s algorithm。&lt;/p>
&lt;/blockquote></description></item><item><title>332. Reconstruct Itinerary</title><link>https://aryido.github.io/posts/leetcode/leetcode332/</link><pubDate>Sat, 17 Sep 2022 10:03:29 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode332/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這種飛航問題基本上都是屬於 Graph 題，題目敘述也很生活化(&lt;del>根本旅行必備知識&lt;/del>)。 因為所有的路徑有且只會被用一次，故是一個 &lt;strong>Euler Circuit&lt;/strong>。&lt;/p>
&lt;p>進一步抽象，可說這題是屬於 &lt;strong>Post-order traversal on Edges&lt;/strong> 問題。 從入口做 &lt;strong>post-order&lt;/strong> ，會是出口先被紀錄，然後再往回 &lt;strong>backtracking&lt;/strong> 回入口，把路上的所有 node 都記下來。 老實說技巧性有點太強，且還是高頻&amp;hellip;。 另外注意英文閱讀，有些單字很重要例如 &lt;em>lexical order&lt;/em>，沒注意到可能會出現錯誤。&lt;/p>
&lt;/blockquote></description></item><item><title>5. Longest Palindromic Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode5/</link><pubDate>Wed, 14 Sep 2022 22:30:14 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>最長回文子串 (Longest Palindromic Substring) 是常考題&lt;/strong>。Palindrome 就是正讀反讀都一樣的詞語，比如範例給的 &amp;ldquo;bab&amp;rdquo;、 &amp;ldquo;bb&amp;rdquo; ，實際單字如 &amp;ldquo;level&amp;rdquo; 等等都屬於它。因為較好的解法是 DP 類型，初見就能想到，難度也比較高。一般人能熟悉 DP 解就好了。(看過令人膜拜的神解 Manacher&amp;rsquo;s Algorithm，時間複雜度提升到了 O(n) &amp;hellip;)&lt;/p>
&lt;/blockquote></description></item><item><title>973. K Closest Points to Origin</title><link>https://aryido.github.io/posts/leetcode/leetcode973/</link><pubDate>Mon, 12 Sep 2022 20:12:28 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode973/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>類似這種 top k 問題且非樹結構，都可以直接用 Heap 來解題。&lt;/p>
&lt;/blockquote></description></item><item><title>230. Kth Smallest Element in a BST</title><link>https://aryido.github.io/posts/leetcode/leetcode230/</link><pubDate>Sun, 11 Sep 2022 16:12:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode230/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道關於二叉搜索樹 Binary Search Tree 的題目。提示是讓我們用&lt;em>中序遍歷In-Order&lt;/em>來解題。 可以複習一下 DFS 解法的 Pre-Order、In-Order Post-Order。 另外這道題的 Follow up 可以多思考，是假設該 BST 被修改的很頻繁，而且查找第 k 小元素的操作也很頻繁，問如何優化。&lt;/p>
&lt;/blockquote></description></item><item><title>200. Number of Islands</title><link>https://aryido.github.io/posts/leetcode/leetcode200/</link><pubDate>Wed, 07 Sep 2022 20:55:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode200/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>剛開始刷題時就覺得這題很有趣，有 game 的感覺。可以用來複習DFS、BFS。&lt;/p></description></item><item><title>735. Asteroid Collision</title><link>https://aryido.github.io/posts/leetcode/leetcode735/</link><pubDate>Mon, 05 Sep 2022 20:42:24 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode735/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p>
&lt;p>這題雖然好玩但我寫起來真的BUG滿天飛，小行星碰撞 Asteroid Collision。&lt;/p></description></item><item><title>739. Daily Temperatures by Java</title><link>https://aryido.github.io/posts/leetcode/leetcode739/</link><pubDate>Mon, 05 Sep 2022 10:59:38 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode739/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item><item><title>57. Insert Interval</title><link>https://aryido.github.io/posts/leetcode/leetcode57/</link><pubDate>Thu, 01 Sep 2022 11:17:02 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode57/</guid><description>&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aryido Tech Note</title><link>https://aryido.github.io/posts/kubernetes/</link><description>Recent content on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 07 May 2023 20:22:59 +0800</lastBuildDate><atom:link href="https://aryido.github.io/posts/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes: command &amp; arguments</title><link>https://aryido.github.io/posts/kubernetes/command-arguments/</link><pubDate>Sun, 07 May 2023 20:22:59 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/command-arguments/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>當我們在編寫 Kubernetes Pod 相關的 yaml spec 時，有時會針對 spec.containers ，設置啟動時要執行的命令及其參數，而 Kubernetes 提供 &lt;code>command &lt;/code> 和 &lt;code>args&lt;/code>，兩種方式可以選擇。但這時候就會出現一些疑問 :&lt;/p>
&lt;ul>
&lt;li>這兩個差異是甚麼 ?&lt;/li>
&lt;li>Docker Image 中如果自帶 Entrypoint 和 CMD ，若 Kubernetes 再設置 command 和 args 會發生甚麼事情呢 ?&lt;/li>
&lt;/ul>
&lt;p>以下就來簡單說明一下。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Pod 實現解析</title><link>https://aryido.github.io/posts/kubernetes/pod-implementation/</link><pubDate>Sat, 01 Apr 2023 17:34:53 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/pod-implementation/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pod 是 Kubernetes 中最小的運行單位，它可以包含一個或多個 container。Pod 的實現原理主要涉及以下幾個方面：&lt;/p>
&lt;ul>
&lt;li>容器技術 : 實現隔離和獨立運行&lt;/li>
&lt;li>共享網絡和存儲 : Pod 中的所有容器共享相同的網絡和存儲空間&lt;/li>
&lt;li>Pod 調度 : 調度器會監測節點的資源利用率，將 Pod 調度到適合的節點上運行。&lt;/li>
&lt;li>生命週期管理 : 當 Pod 發生故障或需要擴展時，控制器會自動創建、刪除或調整 Pod 的數量。&lt;/li>
&lt;/ul>
&lt;p>在 Kubernetes 中，Pod 是容器組的概念，爲應用程序提供了一個更加靈活的運行環境，負責管理容器的生命周期和資源。&lt;/p>
&lt;/blockquote></description></item><item><title>Helm 簡介</title><link>https://aryido.github.io/posts/kubernetes/helm/</link><pubDate>Tue, 21 Mar 2023 22:02:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/helm/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Helm 是 kubernetes 的包管理工具。 Helm 有一個公共 Repository ，裏面主要都是配置文件，會把 Kubernetes 服務中各種元件 yaml ，統一打包成一個叫做 Chart 的模組，然後透過 value.yaml，可用來&lt;strong>統一&lt;/strong>管理與設定 Kubernetes ，幫助 developer 和系統管理員，更輕鬆地部署、管理和升級 Kubernetes 中的應用程式。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - DaemonSet</title><link>https://aryido.github.io/posts/kubernetes/daemonset/</link><pubDate>Tue, 14 Mar 2023 22:35:58 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/daemonset/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>k8s Cluster 並不直接與 Pod 做互動，而是透過一些管理元件來處理 Pod ，這些管理元件總體被稱為 Workload，這裏介紹 DaemonSet 控制器。DaemonSet 用於提供 Node 基本設施的 Pod，會確保在&lt;strong>所有(或是特定)節點&lt;/strong>上，一定運行著指定的一個 Pod。若想只運行在特定節點運行 DaemonSet Pod，可藉由給定的&lt;strong>標籤&lt;/strong>，讓 Pod 可以只在特定節點上運行。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Deployment</title><link>https://aryido.github.io/posts/kubernetes/deployment/</link><pubDate>Mon, 13 Mar 2023 23:52:05 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/deployment/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在 Kubernetes 中，Pod 是最小的管理單元，但是 Pod 並不能保證總是可用的，因此 Kubernetes 實現了一系列控制器來管理 Pod，我們稱為&lt;strong>工作負載 workloads&lt;/strong>。故 workloads 基本可以解釋成管理一個或多個 &lt;strong>Pod&lt;/strong> 的方式，主要簡單舉例以下幾種：&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>DaemonSet&lt;/li>
&lt;li>Job &amp;amp; CronJob&lt;/li>
&lt;li>StatefulSet&lt;/li>
&lt;/ul>
&lt;p>這些稱為控制器，會使 Pod 的期望狀態和設定狀態盡量保持一致。這裏先介紹 Deployment 控制器。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Job 簡介</title><link>https://aryido.github.io/posts/kubernetes/job/</link><pubDate>Thu, 02 Mar 2023 23:10:15 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/job/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們知道 kubernetes 的 deployment 可以生成並管理 Pod ，且盡量維持其狀態為 Running 。但有的時候我們會有&lt;strong>只運行一次性任務的需求&lt;/strong>，這時候就可以使用 &lt;a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">kubernetes Job&lt;/a>。 Kubernetes Job 用於處理一次性工作，會創建一個或多個 Pod，並在該工作完成後終止這些 Pod。&lt;/p>
&lt;/blockquote></description></item><item><title>kubectl 簡單筆記</title><link>https://aryido.github.io/posts/kubernetes/kubectl/</link><pubDate>Sun, 25 Dec 2022 21:38:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/kubectl/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>kubectl 是針對 k8s cluster 的 API Server 發送命令的工具，有些指令會改變 K8s cluster 的 state 和任何對應到的環境變量。默認情況下，kubectl 在 &lt;strong>$HOME/.kube&lt;/strong> 目錄下查找名為 config 的文件，kubectl 使用該 config 文件來查找要通訊的 K8s cluster 資料。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 2</title><link>https://aryido.github.io/posts/kubernetes/overview-2/</link><pubDate>Sat, 24 Dec 2022 12:30:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在上一篇文章中，簡單介紹了 Kubernetes 的架構，接下來簡介 Kubernetes 在部屬 app 時的單位 Pod 。 Pod 對多容器的支持是 K8 最基礎的設計理念，但 Pod 應該怎麼被管理呢 ? 怎麼和外網連線呢 ? 這些部分由如下元件提供功能解決 :&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>Service&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>像在實現進階的操作如:負載均衡、滾動更新、安全與監控等概念，都會跟這些元件有關係。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 1</title><link>https://aryido.github.io/posts/kubernetes/overview-1/</link><pubDate>Mon, 19 Dec 2022 23:38:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>從第一次聽到 Kubernetes 以來，已經有一年多了，永遠都記得 k8s 名稱的由來只是保留「開頭 K」及「結尾 S」，然後中間的英文字母數量剛好是 8 個英文字就這樣命名了&amp;hellip;。全球三大雲服務商，AWS、Azure 和 GCP 都有提供託管 Kubernetes 集群服務( EKS、AKS、GKE )，可見其有名火熱程度。現在終於有機會在工作上碰到這項技術，就來寫些簡單筆記吧 !&lt;/p>
&lt;/blockquote></description></item></channel></rss>
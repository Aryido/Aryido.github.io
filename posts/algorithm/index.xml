<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aryido Tech Note</title><link>https://aryido.github.io/posts/algorithm/</link><description>Recent content on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Oct 2023 20:10:05 +0800</lastBuildDate><atom:link href="https://aryido.github.io/posts/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Backtrack 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/backtrack/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/backtrack/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Backtrack 是 DFS 的一種形式，基本寫法類似於 TOP DOWN DFS，處理方式就是所謂的窮舉法，將所有可能的結果都找出來；每一個結果都實際看看這樣。換個角度來說，其實這個過程就如同在樹上遍歷 (Tree Traversal) ，而普通的 DFS 是不需要回溯狀態的。 Backtrack 強調了狀態回溯。&lt;/p>
&lt;/blockquote></description></item><item><title>Merge Sort</title><link>https://aryido.github.io/posts/algorithm/merge-sort/</link><pubDate>Mon, 04 Sep 2023 21:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/merge-sort/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>歸併排序 (Merge Sort)&lt;/strong> 算是比較優秀的排序算法，因為時間複雜度是 &lt;code>O(N log N)&lt;/code>；而選擇排序、冒泡排序、和插入排序時間複雜度則是&lt;code>O(N^2)&lt;/code>。 Merge Sort 的基本思想是&lt;strong>分治法 (Divide and conquer)&lt;/strong>，是將原問題分解為規模較小的子問題，然後逐一解決這些子問題之後，&lt;strong>合併這些子問題的答案&lt;/strong>，並建立原問題的答案。&lt;/p>
&lt;/blockquote></description></item><item><title>Recursion</title><link>https://aryido.github.io/posts/algorithm/recursion/</link><pubDate>Mon, 04 Sep 2023 20:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/recursion/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>遞迴 (Recursion)&lt;/strong>，通過調用自身函數，有時可以將某個複雜的問題，分解為規模較小的子問題。而 Recursion 也經常和以下演算法配合使用 :&lt;/p>
&lt;ul>
&lt;li>分治法 divide and conquer&lt;/li>
&lt;li>回溯法 backtrack&lt;/li>
&lt;li>動態規劃 dynamic programming&lt;/li>
&lt;/ul>
&lt;p>在實際狀況中，遞迴函數的設計常常很難想像，因為遞迴設計屬於&lt;strong>逆向思維&lt;/strong>，在設計遞迴函數的時候，非常容易被這種層層嵌套搞暈，在這裡簡單給個模板範例講解。&lt;/p>
&lt;/blockquote></description></item><item><title>Multiple points 題型簡單介紹</title><link>https://aryido.github.io/posts/algorithm/multiple-points/</link><pubDate>Wed, 23 Aug 2023 22:50:25 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/multiple-points/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Multiple points 的操作，經常用在 array 或 linkedList 上，有幾點事情可以在刷題時特別注意:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>指標會把 list 切成幾個部分，特別注意每一部份的定義&lt;/p>
&lt;/li>
&lt;li>
&lt;p>list 是否有排序或可以排序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指標移動是使用&lt;strong>快慢指標&lt;/strong>還是&lt;strong>左右指標&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>會不會改變原本的 list&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其中第一點，&lt;strong>把 array 切成幾個部分&lt;/strong>，每個部份的&lt;strong>定義&lt;/strong>，是最重要的思想，可以多思考。&lt;/p>
&lt;/blockquote></description></item><item><title>Dynamic Programming 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/dynamic-programming1/</link><pubDate>Wed, 02 Nov 2022 21:52:00 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/dynamic-programming1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dynamic Programming 大概算是 leetcode 裡面平均難度最高的章節了，還蠻需要練習的。但在講 DP 之前，我們可以先講 Search，因為 Dynamic Programming 其實就是 Search + Memoization。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search - 2 各式模板</title><link>https://aryido.github.io/posts/algorithm/binary-search2/</link><pubDate>Sat, 15 Oct 2022 17:47:39 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/binary-search2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹了 Binary Search 的通用模板，但通用模板還是有缺點，就是要找的目標須在 array 範圍內，這樣才能定義 index。但很多時候題目並不會有一個準確的 array 被定義，還是需要了解各個模板才能比較好的去解答各式題目。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search - 1 觀念介紹</title><link>https://aryido.github.io/posts/algorithm/binary-search1/</link><pubDate>Sat, 15 Oct 2022 16:27:29 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/binary-search1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Binary-Search (二分搜尋法)，是一種針對&lt;strong>已經排好序&lt;/strong>的區間內， &lt;strong>O(logN)&lt;/strong> 的搜索方式。
Binary-Search 在處理邊界時很容易出錯。 基本上都是沒注意到兩大原則 :&lt;/p>
&lt;ul>
&lt;li>每次都一定要縮減收所區域&lt;/li>
&lt;li>每次縮減不能排除潛在答案&lt;/li>
&lt;/ul>
&lt;p>雖然淺顯易見，但實踐在寫的時候還是常常會寫出 bug 。&lt;/p>
&lt;/blockquote></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aryido Tech Note</title><link>https://aryido.github.io/</link><description>Recent content on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2023 22:45:06 +0800</lastBuildDate><atom:link href="https://aryido.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>79. Word Search</title><link>https://aryido.github.io/posts/leetcode/leetcode79/</link><pubDate>Mon, 20 Mar 2023 22:45:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode79/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給定一個 board 以及 一個 word ，我們要判斷的 board 上是否可以連線出 word。這題是蠻典型的 graph 類題目，用 BFS 或 DFS 解題都行，但用深度優先 DFS 來解題會比較好一些(可以先思考一下為什麼)。解題流程還蠻制式化的，是熟練 graph 類型的練習好題目 XD。&lt;/p>
&lt;/blockquote></description></item><item><title>linux 指令範例: set</title><link>https://aryido.github.io/posts/linux/set-example/</link><pubDate>Wed, 15 Mar 2023 22:25:50 +0800</pubDate><guid>https://aryido.github.io/posts/linux/set-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>set 是 shell 內建的命令，適當的使用可以增加腳本的安全性和可維護性，幫助腳本執行時可盡快發現錯誤，從而減少不必要的問題。因此很多 &lt;code>script.sh&lt;/code> 檔，第一行都會加&lt;/p>
&lt;ul>
&lt;li>set -euo pipefail&lt;/li>
&lt;/ul>
&lt;p>這篇文章簡單解釋並記錄一下，可以參考使用。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Deployment</title><link>https://aryido.github.io/posts/kubernetes/deployment/</link><pubDate>Mon, 13 Mar 2023 23:52:05 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/deployment/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在 Kubernetes 中，Pod 是最小的管理單元，但是 Pod 並不能保證總是可用的，因此 Kubernetes 實現了一系列控制器來管理 Pod，我們稱為&lt;strong>工作負載 workloads&lt;/strong>。故 workloads 基本可以解釋成管理一個或多個 &lt;strong>Pod&lt;/strong> 的方式，主要簡單舉例以下幾種：&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>DaemonSet&lt;/li>
&lt;li>Job &amp;amp; CronJob&lt;/li>
&lt;li>StatefulSet&lt;/li>
&lt;/ul>
&lt;p>這些稱為控制器，會使 Pod 的期望狀態和設定狀態盡量保持一致。這裏先介紹 Deployment 控制器。&lt;/p>
&lt;/blockquote></description></item><item><title>76. Minimum Window Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode76/</link><pubDate>Sat, 11 Mar 2023 12:13:17 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode76/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給了我們一個字符 &lt;em>s&lt;/em>，還有一個目標字符 &lt;em>t&lt;/em>，要在 &lt;em>s&lt;/em> 中找到一個 &lt;strong>minimum window substring&lt;/strong> 使得其包含了 &lt;em>t&lt;/em> 中的所有的字母。整體看起來題目難在 :&lt;/p>
&lt;ul>
&lt;li>限制了時間複雜度為 &lt;em>O(n + m)&lt;/em>&lt;/li>
&lt;li>第一次要寫出 bug free 有點困難&lt;/li>
&lt;/ul>
&lt;p>故備標註為 &lt;strong>hard&lt;/strong> ，但整體思路上並不算太難，值得品味一下 !&lt;/p>
&lt;/blockquote></description></item><item><title>linux 指令範例: sed</title><link>https://aryido.github.io/posts/linux/sed-example/</link><pubDate>Mon, 06 Mar 2023 22:56:28 +0800</pubDate><guid>https://aryido.github.io/posts/linux/sed-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;em>sed&lt;/em> 全名為 &lt;em>Stream EDitor&lt;/em> ，取了前面的 &lt;em>S&lt;/em> 和後面的 &lt;em>ED&lt;/em> 來命名。&lt;em>sed&lt;/em> 對正規表示法有良好的支援，主要功能為自動化的修改文字檔，是在 Linux 和 Unix 系統中使用的文本處理工具，可在 pipe 中間進行文字的取代、刪除、插入等等。&lt;/p>
&lt;/blockquote></description></item><item><title>763. Partition Labels</title><link>https://aryido.github.io/posts/leetcode/leetcode763/</link><pubDate>Sun, 05 Mar 2023 22:48:40 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode763/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題給了一個 string，然後要盡可能將 string 切割越多塊 sub-string 越好( as many parts as possible)，其中條件是&lt;strong>每個 char，最多只能出現在自己的 sub-string 中&lt;/strong>。 即 :&lt;/p>
&lt;ul>
&lt;li>分割字串使字串中的每個字母在該分割段落中出現達到最多次。&lt;/li>
&lt;/ul>
&lt;p>題目理解是和自己想解法是比較花時間的，看過解答後都可以很快寫出來。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Job 簡介</title><link>https://aryido.github.io/posts/kubernetes/job/</link><pubDate>Thu, 02 Mar 2023 23:10:15 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/job/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們知道 kubernetes 的 deployment 可以生成並管理 Pod ，且盡量維持其狀態為 Running 。但有的時候我們會有&lt;strong>只運行一次性任務的需求&lt;/strong>，這時候就可以使用 &lt;a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">kubernetes Job&lt;/a>。 Kubernetes Job 用於處理一次性工作，會創建一個或多個 Pod，並在該工作完成後終止這些 Pod。&lt;/p>
&lt;/blockquote></description></item><item><title>18. 4Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode18/</link><pubDate>Wed, 15 Feb 2023 22:17:40 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode18/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>leetcode 幾個數字題，15、16、18，基本上套路都是一樣的(&lt;del>甚至可以預期可能還會出 5 Sum&amp;hellip;&lt;/del>)，整體的解法都差不多可以一起看，重點仍然是 :&lt;/p>
&lt;ol>
&lt;li>排序 array&lt;/li>
&lt;li>避免的重複項&lt;/li>
&lt;/ol>
&lt;p>這邊只是 3Sum 以此基礎上，再加了一個循環而已。 這連續幾題 sum 算是給了一個不錯的練習呢 !&lt;/p>
&lt;/blockquote></description></item><item><title>15. 3Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode15/</link><pubDate>Thu, 09 Feb 2023 22:56:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode15/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>算是 Two Sum 的一種另類進階，從 &lt;em>nums&lt;/em> 中找出和為 0 的三個 element ，並組成 &lt;em>List of list&lt;/em> 。特別注意，不能有兩個內容一樣的 list。因為整個題目並沒有對 &lt;em>nums&lt;/em> 的 &lt;em>index&lt;/em> 有任何要求，故可以&lt;em>把 nums 排序&lt;/em>，為解題拓開另一種思路。&lt;/p>
&lt;/blockquote></description></item><item><title>16. 3Sum Closest</title><link>https://aryido.github.io/posts/leetcode/leetcode16/</link><pubDate>Wed, 08 Feb 2023 21:56:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode16/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題跟 15 題非常相似，又增加了些許難度。題目敘述一樣也簡單，求 nums 內最接近 &lt;em>target&lt;/em> 值的三數和。優化關鍵點一樣是，&lt;em>把 nums 排序&lt;/em>，這樣就可以確定指針滑動方向。&lt;/p>
&lt;/blockquote></description></item><item><title>Apple M1 作業系統坑 - cloud run 出現錯誤</title><link>https://aryido.github.io/posts/others/m1-error-2/</link><pubDate>Sun, 08 Jan 2023 21:54:38 +0800</pubDate><guid>https://aryido.github.io/posts/others/m1-error-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Run 是 Google 的 Serverless 產品，讓我們不用管理基礎 infra 也能建置容器，並會根據流量自動調整資源，且只依據實際使用的資源收費。 這邊特別注意一下，目前 Cloud Run 似乎還沒支持 ARM 格式的 image，故有使用 M1 筆電包 docker image 要特別注意一下，這會出現不可預期的 bug !&lt;/p>
&lt;/blockquote></description></item><item><title>Apple M1 作業系統坑 - CPU 簡介</title><link>https://aryido.github.io/posts/others/m1-error-1/</link><pubDate>Wed, 04 Jan 2023 23:02:30 +0800</pubDate><guid>https://aryido.github.io/posts/others/m1-error-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在公司很多都會給新進員工配上 Apple M1 筆電，整體筆電用起來都還不錯的。但因為 Apple M1 底層處理器架構大改變，對於軟體開發在本地端測試時候，常發生一些不可預期的狀況。這邊就來記錄一下有遇到的 BUG。&lt;/p>
&lt;/blockquote></description></item><item><title>kubectl 簡單筆記</title><link>https://aryido.github.io/posts/kubernetes/kubectl/</link><pubDate>Sun, 25 Dec 2022 21:38:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/kubectl/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>kubectl 是針對 k8s cluster 的 API Server 發送命令的工具，有些指令會改變 K8s cluster 的 state 和任何對應到的環境變量。默認情況下，kubectl 在 &lt;strong>$HOME/.kube&lt;/strong> 目錄下查找名為 config 的文件，kubectl 使用該 config 文件來查找要通訊的 K8s cluster 資料。&lt;/p>
&lt;/blockquote></description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://aryido.github.io/posts/leetcode/leetcode26/</link><pubDate>Sun, 25 Dec 2022 15:05:58 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode26/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題要我們從&lt;strong>有序數組&lt;/strong>中去除重複項，題目難度雖然被歸為 easy 等級，但在&lt;strong>條件限制&lt;/strong>上的討論，蠻多東西可以釐清討論的。 英文方面寫得蠻長，記得看到最後，有些限制如 :&lt;/p>
&lt;ul>
&lt;li>&lt;em>O(1)&lt;/em> extra memory&lt;/li>
&lt;li>The relative order of the elements should be kept the same.&lt;/li>
&lt;/ul>
&lt;p>所以&lt;strong>不要用 Set 或另外 array 去寫&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 2</title><link>https://aryido.github.io/posts/kubernetes/overview-2/</link><pubDate>Sat, 24 Dec 2022 12:30:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在上一篇文章中，簡單介紹了 Kubernetes 的架構，接下來簡介 Kubernetes 在部屬 app 時的單位 Pod 。 Pod 對多容器的支持是 K8 最基礎的設計理念，但 Pod 應該怎麼被管理呢 ? 怎麼和外網連線呢 ? 這些部分由如下元件提供功能解決 :&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>Service&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>像在實現進階的操作如:負載均衡、滾動更新、安全與監控等概念，都會跟這些元件有關係。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 1</title><link>https://aryido.github.io/posts/kubernetes/overview-1/</link><pubDate>Mon, 19 Dec 2022 23:38:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>從第一次聽到 Kubernetes 以來，已經有一年多了，永遠都記得 k8s 名稱的由來只是保留「開頭 K」及「結尾 S」，然後中間的英文字母數量剛好是 8 個英文字就這樣命名了&amp;hellip;。全球三大雲服務商，AWS、Azure 和 GCP 都有提供託管 Kubernetes 集群服務( EKS、AKS、GKE )，可見其有名火熱程度。現在終於有機會在工作上碰到這項技術，就來寫些簡單筆記吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>AWS EKS</title><link>https://aryido.github.io/posts/aws/eks/</link><pubDate>Sat, 17 Dec 2022 18:45:30 +0800</pubDate><guid>https://aryido.github.io/posts/aws/eks/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>ECS 很常拿來與 Kubernetes 比較，而 2017 aws 又進一步宣佈了 Amazon Elastic Container Service for Kubernetes(EKS)，使 aws 平台可以託管 k8s 服務。EKS 服務可以省去安裝以及操作自己的 Kubernetes 叢集的時間，輕鬆的在 AWS 上執行 Kubernetes；進一步地，可使用 Fargate 模式在 &lt;em>EKS&lt;/em> 上，可連 node 機器都不用管理。&lt;/p>
&lt;/blockquote></description></item><item><title>AWS ECS</title><link>https://aryido.github.io/posts/aws/ecs/</link><pubDate>Sat, 17 Dec 2022 16:30:30 +0800</pubDate><guid>https://aryido.github.io/posts/aws/ecs/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Amazon Elastic Container Service（ECS）標誌著 AWS 進入 CaaS 市場。在 Kubernetes 還沒有出現時，各家雲端大廠對於&lt;strong>容器化的管理工具&lt;/strong>都有自己實作。對應在 AWS 上的容器編排平台，是在 2014 年宣佈的 ECS 服務。後續進一步改進，發布 ECS with Fargate，可讓我們運行 container，而&lt;strong>無需管理伺服器或集群&lt;/strong>。 故 Amazon ECS 具有兩個常用模式：&lt;/p>
&lt;ul>
&lt;li>EC2 啟動類型&lt;/li>
&lt;li>Fargate 啟動類型&lt;/li>
&lt;/ul>
&lt;p>以下分別進行介紹。&lt;/p>
&lt;/blockquote></description></item><item><title>Overview Fargate</title><link>https://aryido.github.io/posts/aws/fargate/</link><pubDate>Sat, 17 Dec 2022 16:30:30 +0800</pubDate><guid>https://aryido.github.io/posts/aws/fargate/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>2017年，AWS 推出了 Fargate，這是一個用於部署和管理容器的&lt;strong>模式&lt;/strong>，代表用戶無需管理 EC2 基礎設施。 Fargate 的核心理念就是 &lt;strong>Serverless&lt;/strong> ，讓 ECS 用戶專注於任務和服務定義，而不是管理集群基礎設施，Fargate 可配合用於 &lt;em>ECS&lt;/em> 和 &lt;em>EKS&lt;/em>。&lt;/p>
&lt;/blockquote></description></item><item><title>AWS Overview: ECS | EKS</title><link>https://aryido.github.io/posts/aws/aws-ecs-eks/</link><pubDate>Tue, 13 Dec 2022 21:28:20 +0800</pubDate><guid>https://aryido.github.io/posts/aws/aws-ecs-eks/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>ECS (Elastic Container Service) 和 EKS（Elastic Kubernetes Service）都是 AWS 上提供的 Container Orchestration ( 容器管理工具 )，核心都是&lt;strong>中央控制管理&lt;/strong>運行的容器化應用程式，以下來簡單介紹一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - binary search</title><link>https://aryido.github.io/posts/leetcode/leetcode410-2/</link><pubDate>Sun, 11 Dec 2022 18:32:09 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹用 dp 方式把這題給解了，但看一下 Related Topics 發現也可以用 Binary Search 求解，上網參考大神們的解法，感覺特別巧妙。因為這題可用 dp 和 Binary Search，也變成是一道高頻難題。
這邊記錄一下大神們的想法。&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform Move</title><link>https://aryido.github.io/posts/terraform/terraform-move/</link><pubDate>Sun, 04 Dec 2022 19:31:26 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terraform-move/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>隨著系統的擴充， Terraform 配置也會變得越來越複雜，這時可能會需要做一些 Refactor，例如 :&lt;/p>
&lt;ul>
&lt;li>將某些 terraform resource 移動到其他 module&lt;/li>
&lt;li>change resource ID&lt;/li>
&lt;/ul>
&lt;p>這時候用 terraform plan 檢查一下，會發現 terraform 打算把原本的 resource 移除，然後重新建立一個新的 resource。但 resource 中間被刪掉，之後再造回來是會影響服務的。我們必須讓 Terraform 知道我只是重新命名，這就是 Terraform move 想做的事情。&lt;/p>
&lt;/blockquote></description></item><item><title>47. Permutations II</title><link>https://aryido.github.io/posts/leetcode/leetcode47/</link><pubDate>Sun, 04 Dec 2022 18:41:26 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode47/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 46. Permutations 的進階，現在有 duplicate 數字，一樣使用 backtrack 來求解。從數學上來說，&lt;em>n&lt;/em> 個 element ，且將相同的事物歸為一組, 可歸成&lt;em>k&lt;/em>組, 且每組有&lt;em>m_i&lt;/em>個，其 Permutation 一共有 &lt;em>n!/(m_1!m_2!&amp;hellip;m_k!)&lt;/em> 種排序，高中數學題需要思考下的基礎題，要用程式模擬這個過程也有點難度，被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>46. Permutations</title><link>https://aryido.github.io/posts/leetcode/leetcode46/</link><pubDate>Wed, 30 Nov 2022 23:38:55 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode46/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是一道經典的全排列問題，這邊使用 backtrack 來求解。從數學上來說，&lt;em>n&lt;/em> 個 element 的 Permutation 一共有 &lt;em>n!&lt;/em> 種排序，思考起來算蠻簡單的，但要用程式模擬這個過程，是有點難度的，被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>cloud init 簡介</title><link>https://aryido.github.io/posts/others/cloud-init/</link><pubDate>Tue, 29 Nov 2022 20:23:44 +0800</pubDate><guid>https://aryido.github.io/posts/others/cloud-init/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>cloud-init 是一個 package，可以藉由配置 cloud-init 來執行各種任務，自動初始化 cloud instance。在初次開機時就將想要的檔案或設定與系統一併弄好而不用手動處理。大部分雲平台都支持 cloud-init，目前是 &lt;strong>industry standard (行業標準)&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>Packer build machine image 偶爾會出錯誤</title><link>https://aryido.github.io/posts/others/packer-build-image-error/</link><pubDate>Mon, 28 Nov 2022 22:04:39 +0800</pubDate><guid>https://aryido.github.io/posts/others/packer-build-image-error/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>使用 Packer 建立 AWS EC2 AMI 或者是 GCP Machine Image，兩個都會有機率發生一些問題， 有時候是 image 內一些應用程式安裝出現問題；有時候是再最後啟動 AWS 或 GCP 虛擬機時，使用 user-data 或 startup-script 時會出現問題，共同的錯誤訊息是 &lt;strong>no installation candidate.&lt;/strong> 。 AWS 機率發生體感機率比 GCP 高不少。那問題的根源是什麼呢，來看看吧!&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - dynamic programming</title><link>https://aryido.github.io/posts/leetcode/leetcode410/</link><pubDate>Sun, 27 Nov 2022 20:26:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題真的蠻難的，一開始看題目我也覺得很繞口，給了一個非負數的 nums 和一個 m 代表把 nums 分成 m 個 group 且 每個 group non-empty 並取 m 個 group 中的最大值。但注意，前面只是代表一種&lt;strong>切法&lt;/strong>而已，我們是要找所有可能&lt;strong>切法&lt;/strong>之中的最小值。看一下 Related Topics 發現可以用 Binary Search 和 DP 求解，也是一道高頻題目。&lt;/p>
&lt;/blockquote></description></item><item><title>877. Stone Game</title><link>https://aryido.github.io/posts/leetcode/leetcode877/</link><pubDate>Fri, 25 Nov 2022 23:36:44 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode877/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>石頭遊戲，兩個人輪流選石頭，Alex 先選，每次只能選開頭或結尾，最終獲得石頭總數多的人獲勝。 乍看之下不好想到可以用 DP 解，但其實可用一個 2D-state 去描述遞迴的狀態。 這題一開始會好奇是因為負評倒讚很多，個人是感覺能從 Game Theory 單純想出這結論也是蠻厲害的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform 實用技巧</title><link>https://aryido.github.io/posts/terraform/terraform-skill/</link><pubDate>Thu, 24 Nov 2022 23:07:42 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terraform-skill/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>最近很常寫 Terraform ，知道一些 terraform cli 指令可以幫助自己寫的更好，也在學習 Terraform 的過程中，把覺得值得記錄的一些注意事項 &amp;amp; 小技巧留在這裡。&lt;/p>
&lt;/blockquote></description></item><item><title>1143. Longest Common Subsequence</title><link>https://aryido.github.io/posts/leetcode/leetcode1143/</link><pubDate>Tue, 22 Nov 2022 22:46:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1143/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是求最長相同的&lt;strong>子序列&lt;/strong>，可用 Dynamic Programing 來做，最難的還是想出狀態函數。這裡使用 2D-dp ，其中 dp[i][j] 表示 :&lt;/p>
&lt;ul>
&lt;li>text1 的前 i 個字符&lt;/li>
&lt;li>text2 的前 j 個字符&lt;/li>
&lt;/ul>
&lt;p>的最長相同的子序列的字符個數&lt;/p>
&lt;/blockquote></description></item><item><title>Java賦值語句的返回值</title><link>https://aryido.github.io/posts/java/java-skill-9/</link><pubDate>Sun, 13 Nov 2022 23:32:56 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-9/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Java賦值語句，是有返回值的，而且還並不是想像中的 bool 類型 ！ 想想其實一直都有看到一些類似的用法，但因自己平時開發並沒有特別使用過，也沒有很深入去探討了解。今天在這邊就舉例一些出來，來說明 Java 賦值語句的返回值。&lt;/p>
&lt;/blockquote></description></item><item><title>CIDR 介紹</title><link>https://aryido.github.io/posts/others/cidr/</link><pubDate>Sun, 13 Nov 2022 17:37:27 +0800</pubDate><guid>https://aryido.github.io/posts/others/cidr/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>無類別域間路由（ Classless Inter-Domain Routing ，簡稱 CIDR ）是為了避免造成 IP 位址的大量浪費，於是出現的一種技術。CIDR重點有：&lt;/p>
&lt;ol>
&lt;li>多變長度子網路遮罩 (Variable-Length Subnet Mask，VLSM)&lt;/li>
&lt;li>路由匯總 （Route Summarization）(暫不介紹)&lt;/li>
&lt;/ol>
&lt;/blockquote></description></item><item><title>63. Unique Paths II</title><link>https://aryido.github.io/posts/leetcode/leetcode63/</link><pubDate>Sun, 13 Nov 2022 15:22:47 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode63/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 62. Unique Paths 的延伸，在路徑中加了一些 obstacle ，用 Dynamic Programming 二維的 dp 數組來解題&lt;/p>
&lt;/blockquote></description></item><item><title>139. Word Break</title><link>https://aryido.github.io/posts/leetcode/leetcode139/</link><pubDate>Sat, 12 Nov 2022 22:10:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode139/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>一道很經典的題目，是給定一 string ，能不能分被拆分成 wordDict 裡面的單詞。注意這題，wordDict 裡面的單詞可以重複使用，即單詞使用沒有次數限制，所以 string 可以分成任意段，這就增加了題目的難度。解法蠻多種的，可先從 brute force 下手，再加上暫存優化後，就是蠻標準的 dp 解了，來解一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>IP and Subnet Mask 介紹</title><link>https://aryido.github.io/posts/others/ip-and-subnetmask/</link><pubDate>Mon, 07 Nov 2022 22:55:14 +0800</pubDate><guid>https://aryido.github.io/posts/others/ip-and-subnetmask/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>IP (Internet Protocol) 是電腦的地址。IP 位址在系統中是一個 32 位元的數字，但為了方便人類讀寫，每一個位元組會被轉換成一個十進位的數字。&lt;/p>
&lt;p>IP 位址可以分為 Network ID 和 Host ID，為了讓電腦可以判斷出 IP 位址的 Network ID 及 Host ID，必須靠子網路遮罩 (Subnet Mask) 的幫忙。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/posts/leetcode/leetcode78/</link><pubDate>Sun, 06 Nov 2022 22:54:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題很經典的問題 the power set ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選就可以得出。但在程式上卻有點點難度，會被歸類到 Medium 等級。這邊我是使用類似於一種深度優先搜索，但其實也有非遞回式的解法，都可看看並練習。&lt;/p>
&lt;/blockquote></description></item><item><title>Dynamic Programming 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/dynamic-programming1/</link><pubDate>Wed, 02 Nov 2022 21:52:00 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/dynamic-programming1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dynamic Programming 大概算是 leetcode 裡面平均難度最高的章節了，還蠻需要練習的。但在講 DP 之前，我們可以先講 Search，因為 Dynamic Programming 其實就是 Search + Memoization。&lt;/p>
&lt;/blockquote></description></item><item><title>Datadog V.S Grafana</title><link>https://aryido.github.io/posts/grafana/datadog/</link><pubDate>Mon, 31 Oct 2022 23:35:14 +0800</pubDate><guid>https://aryido.github.io/posts/grafana/datadog/</guid><description>&lt;blockquote>
&lt;p>Datadog 是 2010 年成立，以 infrastructure monitoring 起家。主要是整合多個雲平台如 GCP, AWS, Azure，讓工程師方便監測以進行 debug 。另外可用機器學習方式，將預先對可能發生異常狀況發出警示，是企業級的解決方案。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP load-balancer 的 terraform Module</title><link>https://aryido.github.io/posts/terraform/gcp-aws-terraform-module/</link><pubDate>Sat, 29 Oct 2022 23:17:25 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/gcp-aws-terraform-module/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>目前使用 AWS 和 GCP terraform module 的感想，其實我覺得都還可以。但這邊特別覺得 GCP load-balancer module，我個人感覺寫得真的不好，有很多地方應該可以寫得更好，讓使用者體驗更棒的，但他們並沒做到&amp;hellip;，也讓我思考了其實一昧 module 化是否有必要呢 ? 讓我列出來一些我簡單比較和缺點吧。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP load-balancer 基礎介紹</title><link>https://aryido.github.io/posts/google-cloud/gcp-load-balancer-introduction/</link><pubDate>Sun, 23 Oct 2022 15:10:00 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gcp-load-balancer-introduction/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>GCP 目前也有多種 Load Balancer，console上是大概分成了三個 :&lt;/p>
&lt;ul>
&lt;li>HTTP(S) load balancing&lt;/li>
&lt;li>TCP load balancing&lt;/li>
&lt;li>UPD load balancing&lt;/li>
&lt;/ul>
&lt;p>但實際上依照細部功能，其實有蠻細緻的設定的
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/google-cloud/load-balancer-options.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/google-cloud/load-balancer-options.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>560. Subarray Sum Equals K</title><link>https://aryido.github.io/posts/leetcode/leetcode560/</link><pubDate>Sun, 23 Oct 2022 11:03:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode560/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題我看起來也是很技巧性的題目，一開始要把 subarray 的特性掌握的淋漓盡致，並且想到用 hashmap 來建立快速查找關係，真的有點困難&amp;hellip;但也是這道題的魅力吧 ! 基本上 hashmap 題目大概都會偏向這種步驟應用，多注意可以讓自己視野開闊。&lt;/p></description></item><item><title>Google Cloud CLI : Auth Credentials</title><link>https://aryido.github.io/posts/google-cloud/gcp-cli-3/</link><pubDate>Sat, 22 Oct 2022 16:13:45 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gcp-cli-3/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>最近使用 gcloud CLI 時，有遇到自己錯誤理解的部分，是關於 gcloud 管理的兩組 credentials :&lt;/p>
&lt;ul>
&lt;li>gcloud auth application-default login&lt;/li>
&lt;li>gcloud auth login&lt;/li>
&lt;/ul>
&lt;p>這兩個到底有甚麼不同呢 ? 來記錄一下吧 ~&lt;/p>
&lt;/blockquote></description></item><item><title>AWS load-balancer 基礎介紹</title><link>https://aryido.github.io/posts/aws/aws-load-balancer/</link><pubDate>Mon, 17 Oct 2022 22:00:06 +0800</pubDate><guid>https://aryido.github.io/posts/aws/aws-load-balancer/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>AWS 目前有多種 Load Balancing&lt;/p>
&lt;ul>
&lt;li>Application Load Balancer&lt;/li>
&lt;li>Network Load Balancer&lt;/li>
&lt;li>Classic Load Balancer&lt;/li>
&lt;/ul>
&lt;p>對於 Classic Load Balancer ，除非還有 ec2 運行在 ec2-classic 網路的場景，要不然已經&lt;strong>不建議&lt;/strong>使用了，建議使用 Application Load Balancer 、 Network Load Balancer 取代。&lt;/p>
&lt;/blockquote></description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://aryido.github.io/posts/leetcode/leetcode1011/</link><pubDate>Sat, 15 Oct 2022 19:18:43 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1011/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題是 Google 面試題，在 Hide Hint 中表示可以使用 binary-search 解決，剛開始覺得蠻 tricky 的，但仔細思考會覺得 binary-search 很符合這題目。&lt;/p></description></item><item><title>Binary Search - 2 各式模板</title><link>https://aryido.github.io/posts/algorithm/binary-search2/</link><pubDate>Sat, 15 Oct 2022 17:47:39 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/binary-search2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹了 Binary Search 的通用模板，但通用模板還是有缺點，就是要找的目標須在一個 array 內，這樣才能定義 index ，才能定義 &lt;em>l = -1&lt;/em> 和 &lt;em>r = N&lt;/em> 兩個在 array 區間外的 index。 但很多時候題目並不會有一個準確的 array 定義出來，還是需要了解各個模板才能比較好的去解答各式題目的邊界。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search - 1 觀念介紹</title><link>https://aryido.github.io/posts/algorithm/binary-search1/</link><pubDate>Sat, 15 Oct 2022 16:27:29 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/binary-search1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Binary-Search，二分搜尋法是一種針對&lt;strong>已經排好序區間&lt;/strong>內的 &lt;strong>O(logN)&lt;/strong> 的搜索方式。
Binary-Search 會發現處理邊界時很容易出錯。 基本上都是沒注意到兩大原則 :&lt;/p>
&lt;ul>
&lt;li>每次都一定要縮減收所區域&lt;/li>
&lt;li>每次縮減不能排除潛在答案&lt;/li>
&lt;/ul>
&lt;p>雖然真的淺顯易見，但實踐在寫的時候還是常常會寫出bug。&lt;/p>
&lt;/blockquote></description></item><item><title>127. Word Ladder</title><link>https://aryido.github.io/posts/leetcode/leetcode127/</link><pubDate>Sun, 09 Oct 2022 23:23:53 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode127/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題第一眼其實看不太出來是 graph 題，但仔細分析會發現是一個單詞，然後能 reach 到的是換一個字母的單詞，就是鄰居；然後要找最短路徑。 難就是難在一開始要把問題轉化成一個 graph!&lt;/p>
&lt;/blockquote></description></item><item><title>GCP Filestore vs AWS EFS 收費標準</title><link>https://aryido.github.io/posts/cloud/filestore-vs-efs/</link><pubDate>Fri, 07 Oct 2022 22:03:14 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/filestore-vs-efs/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>雲端資源在使用的時候，可以特別注意收費的部分。 例如 GCP Filestore 和 AWS EFS 都是有關於 file share 的功能，但計費方式卻很不一樣。養成沒事看看雲端 billing 可以幫助止血&amp;hellip;，踩完坑之後就來看看付費公式吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - 整理</title><link>https://aryido.github.io/posts/terraform/terragrunt-5/</link><pubDate>Thu, 06 Oct 2022 22:31:20 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>基本上 terragrunt 的使用和 terraform 都一樣，所以才說 terragrunt 是一層 wrapper。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>terragrunt init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>terragrunt plan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>terragrunt apply
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>和 terraform 都一樣對吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - variables 精簡</title><link>https://aryido.github.io/posts/terraform/terragrunt-4/</link><pubDate>Wed, 05 Oct 2022 23:27:20 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-4/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>變數管理也是一個讓 code 更加 DRY 的方式之一， terragrunt 有蠻多傳遞變數的方式，這邊舉例 inputs&lt;/p>
&lt;/blockquote></description></item><item><title>AWS 與 GCP reliability 不同的地方比較 - 2</title><link>https://aryido.github.io/posts/cloud/reliability2/</link><pubDate>Tue, 04 Oct 2022 22:23:28 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/reliability2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前段時間社群上有人 po 出 GCP 和 AWS 的比較，然後測出 GCP 慘烈的 VM 生成時間和一堆 409 錯誤，聽說有驚動 Google 高層(&lt;del>怕.jpg&lt;/del>)。那現在我們來針對該作者開源的測試程式來看看吧!&lt;/p>
&lt;/blockquote></description></item><item><title>23. Merge k Sorted Lists</title><link>https://aryido.github.io/posts/leetcode/leetcode23/</link><pubDate>Mon, 03 Oct 2022 21:54:34 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode23/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是合併 k 個 linked-list，且每個linked-list 都是有序的，最終要合併成一個大的 linked-list ，且也必須是有序的。用 heap 解題還蠻巧妙的，故紀錄一下&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>JAVA Map方法： merge &amp; compute 比對</title><link>https://aryido.github.io/posts/java/java-skill-8/</link><pubDate>Sat, 01 Oct 2022 16:36:17 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-8/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Java 8 因為引入了 lambda 這樣的 functional 函數，所以 Map 系列增加了一些方法，感覺還是很好用的，簡單做一些相關介紹 &amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - provider 精簡</title><link>https://aryido.github.io/posts/terraform/terragrunt-3/</link><pubDate>Thu, 29 Sep 2022 22:40:07 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-3/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Provide 是整個 terraform 最重要的元件，是決定要對哪一個平台操作 (e.g. AWS, Azure, gcp)，負責和雲端 API 的接口交互，可以在不了解 API 細節的情況下，通過 terraform 來編排資源。&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - Backend / State 設定自動化</title><link>https://aryido.github.io/posts/terraform/terragrunt-2/</link><pubDate>Tue, 27 Sep 2022 22:55:22 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Terraform Backend 可將 Terraform State 存儲在雲端位置，例如 S3 bucket, azure blob storage, gcp cloud storage，並提供 lock 以防止 race conditions 。 Terragrunt 還進一步讓流程更簡便&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - Introduce</title><link>https://aryido.github.io/posts/terraform/terragrunt-1/</link><pubDate>Tue, 27 Sep 2022 20:45:15 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Terragrunt 是 gruntwork 推出的一個 Terraform thin wrapper，在執行 Terraform 前可以先&lt;strong>調整&lt;/strong> root module 內的 .tf 檔案，保持程式碼的精簡，並提供許多額外的工具和框架幫助開發，藉此可以讓你的 IaC code 更貼近 DRY 原則。&lt;/p>
&lt;/blockquote></description></item><item><title>Parallel、Concurrent 介紹</title><link>https://aryido.github.io/posts/others/os-2/</link><pubDate>Mon, 26 Sep 2022 22:02:41 +0800</pubDate><guid>https://aryido.github.io/posts/others/os-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面介紹了 Program、Process、Thread 差異。再來淺談Parallel、Concurrent 吧! 其實主要是要注意中英文對照&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>297. Serialize and Deserialize Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode297/</link><pubDate>Sun, 25 Sep 2022 14:57:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode297/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題使用深度優先 Depth First Traversal 來遍歷，並使用 Pre-Order 方式記錄樹的節點值；Deserialize 時有用到 queue 來儲存節點 value 值。
之前文章也分享過，在想要 Copy Tree 時適合使用Pre-Order。這題有點符合 Copy Tree 的情境，但是是把 value 存下來。&lt;/p>
&lt;/blockquote></description></item><item><title>AWS 與 GCP reliability 不同的地方比較 - 1</title><link>https://aryido.github.io/posts/cloud/reliability1/</link><pubDate>Sat, 24 Sep 2022 19:31:37 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/reliability1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>近期有機會來比較一下 AWS 和 GCP 的一些差別，也看了一些文章(&lt;del>練英文QQ&lt;/del>)。 GCP 和 AWS 都有 auto scaling 的功能，當我們在某些時候，需要比較多的資源處理事情時，可以自動增加機器來維持高 reliability。 那這部分 GCP 和 AWS 有甚麼區別呢 ?&lt;/p>
&lt;/blockquote></description></item><item><title>Program、Process、Thread 差異</title><link>https://aryido.github.io/posts/others/os-1/</link><pubDate>Sat, 24 Sep 2022 18:07:17 +0800</pubDate><guid>https://aryido.github.io/posts/others/os-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Program/Process/Thread 是面試時經常會被問到的題目，中文部分翻譯有很多種，也來筆記一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>JAVA Map方法：compute、computeIfAbsent、put、putIfAbsent</title><link>https://aryido.github.io/posts/java/java-skill-7/</link><pubDate>Thu, 22 Sep 2022 21:58:05 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-7/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>Map 是 Java 的其中一 interface，不是collection，也不會繼承 Collection interface。
JDK8 的 Map API 有不少便利的預設方法，以下可以介紹一下。&lt;/p></description></item><item><title>Terratag</title><link>https://aryido.github.io/posts/terraform/terratag/</link><pubDate>Wed, 21 Sep 2022 23:11:25 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terratag/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Terratag 是個 CLI 工具，可簡化 resource tag 的方式，允許將標籤應用於整個 Terraform 或 Terragrunt，對於 Terraform 社群來說，他們希望&lt;strong>集中化&lt;/strong>來標註 resource 而不是分別寫在每個resource內，以更方便的追蹤和管理&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>743. Network Delay Time</title><link>https://aryido.github.io/posts/leetcode/leetcode743/</link><pubDate>Mon, 19 Sep 2022 21:09:18 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode743/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>可以抽象成，計算從&lt;strong>初始節點&lt;/strong>到&lt;strong>最遠節點&lt;/strong>的最優路徑，很標準的 &lt;em>best first search&lt;/em>。 題目常用在水管滲透，或是網路流通，求出初始節點到每一個點到最短時間，然後取其中最大的一個就是需要的時間了。這題就是要你=實作 Dijkstra’s algorithm。&lt;/p>
&lt;/blockquote></description></item><item><title>ArrayList &amp; LinkedList 選擇場景</title><link>https://aryido.github.io/posts/java/java-skill-6/</link><pubDate>Sat, 17 Sep 2022 12:49:55 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-6/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在 &lt;a href="https://leetcode.com/problems/reconstruct-itinerary/">&lt;strong>leetcode 332. Reconstruct Itinerary&lt;/strong>&lt;/a> ，答案須回傳 &lt;strong>List&lt;/strong>。因為題目是 &lt;strong>Post-order traversal on Edges&lt;/strong> ，所以添加答案要往第一個元素插入。 這裡就是一個可以使用 &lt;strong>LinkedList&lt;/strong> 而非 &lt;strong>ArrayList&lt;/strong> 的好情境!&lt;/p>
&lt;/blockquote></description></item><item><title>Java 技巧 - computeIfAbsent() 用法詳解</title><link>https://aryido.github.io/posts/java/java-skill-5/</link><pubDate>Sat, 17 Sep 2022 12:44:22 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>使用 HashMap 的方法 :&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-jav" data-lang="jav">computeIfAbsent(K key, Function remappingFunction)
&lt;/code>&lt;/pre>&lt;p>其中 &lt;em>remappingFunction&lt;/em> 是一個 &lt;strong>Functional interface&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>input 為 map 的 &lt;strong>key&lt;/strong>&lt;/li>
&lt;li>output 會成為 map 的 &lt;strong>value&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>332. Reconstruct Itinerary</title><link>https://aryido.github.io/posts/leetcode/leetcode332/</link><pubDate>Sat, 17 Sep 2022 10:03:29 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode332/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這種飛航問題基本上都是屬於 Graph 題，題目敘述也很生活化(&lt;del>根本旅行必備知識&lt;/del>)。 因為所有的路徑有且只會被用一次，故是一個 &lt;strong>Euler Circuit&lt;/strong>。&lt;/p>
&lt;p>進一步抽象，可說這題是屬於 &lt;strong>Post-order traversal on Edges&lt;/strong> 問題。 從入口做 &lt;strong>post-order&lt;/strong> ，會是出口先被紀錄，然後再往回 &lt;strong>backtracking&lt;/strong> 回入口，把路上的所有 node 都記下來。 老實說技巧性有點太強，且還是高頻&amp;hellip;。 另外注意英文閱讀，有些單字很重要例如 &lt;em>lexical order&lt;/em>，沒注意到可能會出現錯誤。&lt;/p>
&lt;/blockquote></description></item><item><title>Google Cloud CLI : Access Token</title><link>https://aryido.github.io/posts/google-cloud/gcp-cli-2/</link><pubDate>Sat, 17 Sep 2022 00:23:55 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gcp-cli-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>使用 GCP 時，都要登入雲端才能獲得授權。 gcloud CLI 提供了兩個方式：&lt;/p>
&lt;ul>
&lt;li>User account authorization&lt;/li>
&lt;li>Service account authorization&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Google Cloud CLI : Initialization GCP Project</title><link>https://aryido.github.io/posts/google-cloud/gcp-cli-1/</link><pubDate>Thu, 15 Sep 2022 23:13:26 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gcp-cli-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>gcloud CLI 可以用於創建和管理 gcp 資源的工具。雖然可以使用 CLI 從命令行或腳本，自動化執行許多常見的任務。但更多是會用例如 &lt;strong>Terraform&lt;/strong> 來部屬資源。故現在基本上用最多是在初始化&lt;/p>
&lt;ul>
&lt;li>&lt;strong>管理身份驗證(manage authentication)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>自定義本地配置(customize local configuration)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>這些和權限管理、project設定有關的功能。&lt;/p>
&lt;/blockquote></description></item><item><title>5. Longest Palindromic Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode5/</link><pubDate>Wed, 14 Sep 2022 22:30:14 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道常考題，也因為是 DP，難度也比較高。 看過令人膜拜的神解 Manacher&amp;rsquo;s Algorithm，時間複雜度提升到了 O(n) ，但一般人還是熟悉一般 DP 解就好了&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Graph 介紹</title><link>https://aryido.github.io/posts/data-structure/graph/</link><pubDate>Tue, 13 Sep 2022 21:37:08 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/graph/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Graph 用於表示物體與物體之間存在某種關係的結構，是內存中不一定連續的資料，每個節點會一個或多個 Reference 指向其他節點&lt;/p>
&lt;ul>
&lt;li>可能有環&lt;/li>
&lt;li>分無向圖和有向圖&lt;/li>
&lt;li>沒有固定入口&lt;/li>
&lt;li>可能有多個入口&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>973. K Closest Points to Origin</title><link>https://aryido.github.io/posts/leetcode/leetcode973/</link><pubDate>Mon, 12 Sep 2022 20:12:28 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode973/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>類似這種 top k 問題且非樹結構，都可以直接用 Heap 來解題。&lt;/p>
&lt;/blockquote></description></item><item><title>230. Kth Smallest Element in a BST</title><link>https://aryido.github.io/posts/leetcode/leetcode230/</link><pubDate>Sun, 11 Sep 2022 16:12:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode230/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道關於二叉搜索樹 Binary Search Tree 的題目。提示是讓我們用&lt;em>中序遍歷In-Order&lt;/em>來解題。 可以複習一下 DFS 解法的 Pre-Order、In-Order Post-Order。 另外這道題的 Follow up 可以多思考，是假設該 BST 被修改的很頻繁，而且查找第 k 小元素的操作也很頻繁，問如何優化。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search Tree</title><link>https://aryido.github.io/posts/data-structure/binary-search-tree/</link><pubDate>Sun, 11 Sep 2022 14:53:52 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/binary-search-tree/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>二元搜尋樹（英語：Binary Search Tree），也稱為有序二元樹（ordered binary tree）或排序二元樹（sorted binary tree）。 從 wiki 上得到的時間與空間複雜度 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">演算法&lt;/th>
&lt;th style="text-align:center">平均&lt;/th>
&lt;th style="text-align:center">最差&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">空間&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">搜尋&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">插入&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">刪除&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/blockquote></description></item><item><title>Java 技巧 - Java Arrays 方法</title><link>https://aryido.github.io/posts/java/java-skill-4/</link><pubDate>Fri, 09 Sep 2022 19:59:56 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-4/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>刷題時很常出現 Array 的結構如 &lt;code>int[]、char[]&lt;/code> 等等&amp;hellip;，故在這邊條列一些常用的 Arrays 方法。
在使用過程也可以複習 java 提供的工具類，還有一些泛型的坑&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Grafana: panel之間共享查詢結果以減少loading時間</title><link>https://aryido.github.io/posts/grafana/panel-loading-enhancement/</link><pubDate>Thu, 08 Sep 2022 22:18:02 +0800</pubDate><guid>https://aryido.github.io/posts/grafana/panel-loading-enhancement/</guid><description>&lt;blockquote>
&lt;p>Grafana 的 panel 會連接 datasource 並發出請求。 故當我們向 dashboard 中添加多個 panel 時，會發出更多的請求，這可能會導致需要更長的時間來loading資料。&lt;/p>
&lt;/blockquote></description></item><item><title>200. Number of Islands</title><link>https://aryido.github.io/posts/leetcode/leetcode200/</link><pubDate>Wed, 07 Sep 2022 20:55:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode200/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>剛開始刷題時就覺得這題很有趣，有 game 的感覺。可以用來複習DFS、BFS。&lt;/p></description></item><item><title>Java 技巧 - 處理Map&lt;K, Collection&lt;T>></title><link>https://aryido.github.io/posts/java/java-skill-3/</link><pubDate>Tue, 06 Sep 2022 23:28:59 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-3/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>經常有一些業務邏輯要用 Map 來解決，如果再多懂得一些 Map 的方法，是可以寫出精簡的 code 的。這裡展示一些優雅處理 &lt;code>Map&amp;lt;K, Collection&amp;lt;T&amp;gt;&amp;gt;&lt;/code> 類型的方式。&lt;/p>
&lt;/blockquote></description></item><item><title>735. Asteroid Collision</title><link>https://aryido.github.io/posts/leetcode/leetcode735/</link><pubDate>Mon, 05 Sep 2022 20:42:24 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode735/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p>
&lt;p>這題雖然好玩但我寫起來真的BUG滿天飛，小行星碰撞 Asteroid Collision。&lt;/p></description></item><item><title>739. Daily Temperatures by Java</title><link>https://aryido.github.io/posts/leetcode/leetcode739/</link><pubDate>Mon, 05 Sep 2022 10:59:38 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode739/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item><item><title>Stack、Deque、ArrayDeque、LinkedList 介紹</title><link>https://aryido.github.io/posts/java/java-skill-2/</link><pubDate>Mon, 05 Sep 2022 00:54:48 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Java 現在 Stack 類已經不建議使用。現在推薦的是使用雙端隊列接口 Deque 取代 Stack。&lt;/p>
&lt;p>Deque 是 interface，有兩個常用的 implement :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ArrayDeque&lt;/strong>&lt;/li>
&lt;li>&lt;strong>LinkedList&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>簡單來介紹和比較一下。&lt;/p>
&lt;/blockquote></description></item><item><title>建立自己的 grafana dashboard plugin - 2</title><link>https://aryido.github.io/posts/grafana/grafana-dashboard-plugin-2/</link><pubDate>Sun, 04 Sep 2022 11:17:52 +0800</pubDate><guid>https://aryido.github.io/posts/grafana/grafana-dashboard-plugin-2/</guid><description>&lt;blockquote>
&lt;p>參考&lt;a href="https://grafana.com/tutorials/build-a-panel-plugin/">官方教學&lt;/a>遇到的一些小問題&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>建立自己的 grafana dashboard plugin - 1</title><link>https://aryido.github.io/posts/grafana/grafana-dashboard-plugin-1/</link><pubDate>Sun, 04 Sep 2022 11:17:02 +0800</pubDate><guid>https://aryido.github.io/posts/grafana/grafana-dashboard-plugin-1/</guid><description>&lt;blockquote>
&lt;p>雖然 Grafana 已經內置了多種類型的dashboard，但有時候可能會覺得官方或其他免費開源plugin，提供的功能不太夠。這時就需要建立自己的dashboard。&lt;/p>
&lt;/blockquote></description></item><item><title>57. Insert Interval</title><link>https://aryido.github.io/posts/leetcode/leetcode57/</link><pubDate>Thu, 01 Sep 2022 11:17:02 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode57/</guid><description>&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item><item><title>Java 泛型注意事項 - List of array 轉成 2D-array</title><link>https://aryido.github.io/posts/java/2d-array/</link><pubDate>Thu, 01 Sep 2022 08:11:32 +0800</pubDate><guid>https://aryido.github.io/posts/java/2d-array/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>把 List of array 轉成 2D-array&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 記得 list.size()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 後面還有個[]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>T result&lt;span style="color:#f92672">[][]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toArray&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> T&lt;span style="color:#f92672">[&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()][]);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 實際 example
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> listOfIntegers &lt;span style="color:#f92672">=&lt;/span> List&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">of&lt;/span>&lt;span style="color:#f92672">(&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">},&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#ae81ff">55&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#ae81ff">65&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> array2D &lt;span style="color:#f92672">=&lt;/span> listOfIntegers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toArray&lt;/span>&lt;span style="color:#f92672">(&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>listOfIntegers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()][]&lt;/span> &lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote></description></item></channel></rss>